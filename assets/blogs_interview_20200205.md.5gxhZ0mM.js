import{_ as e,c as t,o as a,a3 as o}from"./chunks/framework.DpzXWsSh.js";const x=JSON.parse('{"title":"Vue1.x -- 源码剖析","description":"","frontmatter":{"title":"Vue1.x -- 源码剖析","date":"2020-2-05","categories":["vue","面试"]},"headers":[],"relativePath":"blogs/interview/20200205.md","filePath":"blogs/interview/20200205.md"}'),r={name:"blogs/interview/20200205.md"},c=o('<h2 id="vue1-x-源码剖析" tabindex="-1">Vue1.x -- 源码剖析 <a class="header-anchor" href="#vue1-x-源码剖析" aria-label="Permalink to &quot;Vue1.x -- 源码剖析&quot;">​</a></h2><blockquote><p>面试官问: Vue1.x数据响应式是如何实现的?</p></blockquote><ul><li>答:</li></ul><p>vue数据响应式的核心原理是 <code>Object.defineProperty</code>通过递归遍历整个data对象，为对象中的每个key设置一个<code>getter、setter</code>。如果key为数组则走数组响应式的流程。</p><p>数组响应式是通过<code>Object.defineProperty</code> 去拦截数组的七个方法实现的。首先增强了那个七个方法，在完成方法本职工作的基础上增加了依赖通知更新的能力，而且如果有新增数据，则新数据也会被进行响应式处理。数据响应式更新的能力是通过数据响应式拦截结合Dep、Watcher、编译器来实现的。</p><p>当做完数据初始化工作以后〈即响应式拦截)，就进入挂载阶段，开始编译整棵DOM树，编译过程中碰到响应式数据，实例化Watcher，这时会发生数据读取操作，触发getter，进行依赖收集，将Watcher实例放到当前响应式属性对应的dep中。</p><p>待将来响应式数据更新时，触发setter，然后触发dep通知自己收集的所有Watcher实例去执行update方法，触发回调函数的执行，从而更新DOM。</p><p>以上Vue1.x的整个响应式原理的实现。</p><blockquote><p>面试官问:你如何评价Vue1.x响应式原理的设计?</p></blockquote><ul><li>答：</li></ul><p>Vue1.x其实是尤大为了解决自己工作上的痛点而实现的，当时他觉得各种DOM操作太繁琐了，初始化时需要通过DOM操作将数据设置到节点上，还要监听DOM操作，当DOM更新时，更新相应的数据。于是他就想着能不能把这个过程自动化,这就产生了Vue1.x。</p><p>这么一想，Vue1.x的实现其实就很合理了，确实达到了预期的目标。通过Object.defineProperty 拦截数据的读取和设置，页面初次渲染时，通过编译器编译整棵DOM树，给DOM节点设置初始值，当DOM节点更新时又自动更新了响应式数据，或者响应式数据更新时，通过 Watcher自动更新对应的DOM节点。</p><p>这个时候的Vue在完成中小型Web系统是没有任何问题的。而且相比于Vue 2.x性能会更好，因为响应式数据更新时，Watcher可以直接更新对应的DOM节点，没有2.x的VNode开销和Diff过程。</p><p>但是大型Web系统就搞不定了，理由也很简单，也是因为它的设计。因为Vue1.x中 Watcher和模版中响应式数据是——对应关系，也就是说页面中每引用一次响应式数据，就会产生一个Watcher。在大型系统中，一个页面的数据量可能是非常大的，那就会产生大量的 Watcher，占用大量资源，导致性能下降。</p><p>所以一句话总结就是，Vue1.x在中小型系统中性能会很好，定向更新DOM节点，但是大型系统由于Watcher太多，导致资源占用过多，性能下降。</p>',15),p=[c];function u(i,d,l,s,_,n){return a(),t("div",null,p)}const V=e(r,[["render",u]]);export{x as __pageData,V as default};
