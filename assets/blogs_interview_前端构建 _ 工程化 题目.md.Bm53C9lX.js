import{_ as s,c as i,o as a,a5 as l}from"./chunks/framework.BIhQMg0k.js";const c=JSON.parse('{"title":"面试宝典 - 前端构建 & 工程化 题目","description":"","frontmatter":{"title":"面试宝典 - 前端构建 & 工程化 题目","needVerify":true,"date":"2024-12-12T00:00:00.000Z","categories":["面试","工程化"]},"headers":[],"relativePath":"blogs/interview/前端构建 & 工程化 题目.md","filePath":"blogs/interview/前端构建 & 工程化 题目.md"}'),n={name:"blogs/interview/前端构建 & 工程化 题目.md"},t=l(`<h1 id="前端构建-工程化-题目" tabindex="-1">前端构建 &amp; 工程化 题目 <a class="header-anchor" href="#前端构建-工程化-题目" aria-label="Permalink to &quot;前端构建 &amp; 工程化 题目&quot;">​</a></h1><h2 id="_1-webpack-的作用" tabindex="-1">1. webpack 的作用 <a class="header-anchor" href="#_1-webpack-的作用" aria-label="Permalink to &quot;1. webpack 的作用&quot;">​</a></h2><p>webpack 是现代前端工程化的核心工具，主要解决以下问题：</p><ul><li><strong>模块打包</strong>: 将分散的模块打包成优化的生产资源</li><li><strong>资源处理</strong>: 处理各类资源文件(JS/CSS/图片等)的加载和转换</li><li><strong>开发效率</strong>: 提供开发服务器和热更新</li><li><strong>代码优化</strong>: 提供代码分割、tree shaking等优化机制</li><li><strong>兼容性</strong>: 通过各类loader处理兼容性问题</li></ul><p>实际应用示例:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        entry: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./src/index.js&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        output: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;[name].[contenthash].js&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        module: {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            rules: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">js</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                    use: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;babel-loader&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">                }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h2 id="_2-webpack-的构建流程" tabindex="-1">2. Webpack 的构建流程 <a class="header-anchor" href="#_2-webpack-的构建流程" aria-label="Permalink to &quot;2. Webpack 的构建流程&quot;">​</a></h2><p>webpack构建过程可分为以下关键阶段：</p><ol><li><strong>读取配置文件:</strong> Webpack 首先会读取项目中的配置文件(通常是 <code>webpack.config.js</code> )，该配置文件包含了构建过程中的各种设置，如入口文件、输出目录、加载器(loaders)、插件(plugins)等</li><li><strong>解析入口文件:</strong> Webpack 会根据配置文件中定义的入口点(entry points)来解析应用程序的依赖关系。入口文件通常是应用程序的主要 JavaScript 文件，但也可以有多个入口点。</li><li><strong>依赖解析:</strong> Webpack分析入口文件和其依赖的模块，构建一个依赖关系图，以确定哪些模块依赖于其他模块以及它们之间的依赖关系。</li><li><strong>加载器处理:</strong> Webpack 使用加载器来处理不同类型的资源文件，如CSS、图片、字体等。加载器允许开发人员在构建过程中转换这些资源文件，以便将它们整合到最终的输出文件中。</li><li><strong>插件处理:</strong> Webpack 提供了插件系统，插件用于执行各种任务，如代码压缩、资源优化、HTML生成、热模块替换(HMR)等。插件可以根据需要自定义Webpack的构建过程。</li><li><strong>生成输出文件:</strong> Webpack 根据入口文件和依赖关系图生成一个或多个输出文件。这些输出文件包括 JavaScript 文件、CSS文件、图片、字体等资源文件。</li><li><strong>优化和压缩:</strong> Webpack可以进行各种优化，包括代码压缩、Tree Shaking、懒加载等，以减小包的大小并提高性能。</li><li><strong>生成Source Maps:</strong> Webpack可以生成Source Maps，以便在开发中讲行调试。Source Maps是一种映射文件，将最终输出文件映射回原始源代码，</li><li><strong>输出到指定目录:</strong> 最终的构建结果被输出到配置文件中指定的目录中，通常是一个名为&quot;dist&quot;的目录。输出文件的命名和目录结构也可以根据配置进行自定义，</li><li><strong>完成构建过程:</strong> Webpack构建过程完成后，它会生成构建报告，包括构建成功或失败的信息，输出文件的大小等统计信息。</li></ol><p>核心流程示例:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  run</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.hooks.beforeRun.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">call</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.compilation </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Compilation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.compilation.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">build</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">emitAssets</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    });</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_3-webpack-的热更新原理" tabindex="-1">3. Webpack 的热更新原理 <a class="header-anchor" href="#_3-webpack-的热更新原理" aria-label="Permalink to &quot;3. Webpack 的热更新原理&quot;">​</a></h2><p>HMR(Hot Module Replacement)的工作原理：</p><ol><li><strong>webpack-dev-server建立websocket连接</strong></li><li><strong>监控文件变化:</strong> Webpack的开发服务器会监控项目中所有的模块文件，包括:JS文件、CSS文件、模板文件等。</li><li><strong>模块热替换:</strong> 当你在代码中做出更改并保存时，Webpack检测到文件变化，会首先通过热替换插件(HotModule Replacement Plugin)生成新的模块代码。</li><li><strong>构建更新的模块:</strong> 生成的新模块代码会被构建成一个独立的文件或数据块</li><li><strong>通知客户端:</strong> Webpack开发服务器会将更新的模块代码的信息发送到浏览器。</li><li><strong>浏览器端处理:</strong> 浏览器接收到更新的模块信息后，会在不刷新页面的情况下通过热替换运行时(Hot Module Replacement Runtime)替换相应的模块。</li><li><strong>应用程序状态保持:</strong> 热更新还可以保持应用程序的状态。当修改代码不会丢失已有的数据、用户登录状态等</li><li><strong>回调处理:</strong> 允许在模块更新时执行自定义的回调函数，可以处理特定的逻辑，以确保模块更新后的正确性，</li></ol><h2 id="_4-webpack-常用-loader" tabindex="-1">4. webpack 常用 Loader <a class="header-anchor" href="#_4-webpack-常用-loader" aria-label="Permalink to &quot;4. webpack 常用 Loader&quot;">​</a></h2><p>loader是webpack的核心概念，常用loader包括：</p><ul><li><strong>Babel Loader:</strong> 用于将新版 JavaScript(如ES6+) 转换为旧版 JavaScript，以确保在不同浏览器中的兼容性。解决了不同JavaScript版本之间的问题。</li><li><strong>CSS Loader:</strong> 处理CSS文件，使其能够被打包到应用程序中。可以配合其他Loader(如style-loader)一起使用，以处理CSS的导入、模块化等问题。</li><li><strong>Style Loader:</strong> 将CSS样式加载到页面中，通常与CSS Loader一起使用。</li><li><strong>File Loader:</strong> 处理文件资源(如图片、字体等)，将它们复制到输出目录，并返回文件路径。</li><li><strong>URL Loader:</strong> 与File Loader类似，但可以将小文件转换为Base64编码的Data URL，以减小HTTP请求的数量。</li><li><strong>Sass/SCSS Loader:</strong> 处理Sass或SCSS样式文件，将它们转换为CSS，以便在浏览器中使用。</li><li><strong>Less Loader:</strong> 处理Less样式文件，将它们转换为CSS</li><li><strong>PostCSS Loader:</strong> 通过PostCSS插件对CSS进行转换，以实现自动前缀、代码压缩、变量替换等任务。</li><li><strong>Image Loader:</strong> 处理图片文件，包括压缩、优化和Base64编码等操作。</li><li><strong>Vue Loader:</strong> 用于加载和解析 Vue.js 单文件组件，包括模板、脚本和样式</li><li><strong>TypeScript Loader:</strong> 将 TypeScript 代码转换为 JavaScript ，使其可以在浏览器中运行。</li><li><strong>ESLint Loader:</strong> 与ESLint集成，用于在构建过程中进行代码质量检査，查找潜在的问题并确保代码规范</li></ul><p>使用示例:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  rules</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">js</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      use: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;babel-loader&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      test:</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> /</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\.</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">css</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">$</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      use: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;style-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;css-loader&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  ]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_5-webpack-常用-plugin" tabindex="-1">5. webpack 常用 Plugin <a class="header-anchor" href="#_5-webpack-常用-plugin" aria-label="Permalink to &quot;5. webpack 常用 Plugin&quot;">​</a></h2><p>plugin用于执行范围更广的任务，常用插件：</p><ul><li><p><strong>HtmlWebpackPlugin</strong>: 用于生成HTML文件，并自动引入打包后的JavaScript和CSS文件。它还支持模板，可以根据模板生成HTML，非常适合单页应用。</p></li><li><p><strong>MiniCssExtractPlugin</strong>: 用于提取CSS文件到单独的文件，而不是将CSS嵌入到JavaScript中，这有助于提高性能和代码可维护性。</p></li><li><p><strong>CleanWebpackPlugin</strong>: 用于在每次构建前清理输出目录，确保输出目录中不会残留旧的文件。</p></li><li><p><strong>CopyWebpackPlugin</strong>: 用于复制静态文件(如图片、字体等)到输出目录，以便在生产环境中引用。</p></li><li><p><strong>DefinePlugin</strong>: 允许你在代码中定义全局常量，用于在开发和生产环境中切换配置，例如设置API的不同地址。</p></li><li><p><strong>HotModuleReplacementPlugin</strong>: 用于启用Webpack的热模块替换(HMR)功能，允许在开发过程中实时查看代码更改的效果。</p></li><li><p><strong>ProvidePlugin</strong>: 用于在代码中自动加载模块，可以减少模块导入的代码，例如自动引入jQuery等。</p></li><li><p><strong>BundleAnalyzerPlugin</strong>: 用于分析构建输出的包大小，帮助识别和解决优化问题。</p></li><li><p><strong>FriendlyErrorsWebpackPlugin</strong>: 改善开发体验，提供更友好的构建错误信息，以便更容易定位问题。</p></li><li><p><strong>ESLintWebpackPlugin</strong>: 集成ESLint代码检查，用于在构建过程中检测和修复代码问题。</p></li><li><p><strong>stylelint-webpack-plugin</strong>: 用于集成stylelint，对CSS和Sass等样式文件进行代码检查。</p></li></ul><p>配置示例:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">plugins</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> HtmlWebpackPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    template: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;./src/index.html&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }),</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MiniCssExtractPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    filename: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;[name].[contenthash].css&#39;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  })</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><h2 id="_6-loader-和-plugin-的区别" tabindex="-1">6. Loader 和 Plugin 的区别 <a class="header-anchor" href="#_6-loader-和-plugin-的区别" aria-label="Permalink to &quot;6. Loader 和 Plugin 的区别&quot;">​</a></h2><p>主要区别:</p><ul><li><strong>Loader</strong>: 转换器,处理文件级别的转换</li><li><strong>Plugin</strong>: 扩展器,处理bundle级别的优化,整个构建过程都可以介入</li></ul><p>工作流程:</p><ul><li>Loader: 链式调用,从后往前执行</li><li>Plugin: 基于事件机制工作,监听webpack构建过程的事件钩子</li></ul><h2 id="_7-写一个-loader" tabindex="-1">7. 写一个 loader <a class="header-anchor" href="#_7-写一个-loader" aria-label="Permalink to &quot;7. 写一个 loader&quot;">​</a></h2><p>loader本质是一个函数,接收源文件内容,返回转换后的内容:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 一个简单的将代码转换为大写的loader</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // source为源文件内容</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">toUpperCase</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 带配置的loader</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    module</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">exports</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> options</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">getOptions</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replace</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\[</span><span style="--shiki-light:#032F62;--shiki-dark:#DBEDFF;">name</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;--shiki-light-font-weight:bold;--shiki-dark-font-weight:bold;">\\]</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">/</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">g</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, options.name);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span></code></pre></div><h2 id="_8-写一个-plugin" tabindex="-1">8. 写一个 Plugin <a class="header-anchor" href="#_8-写一个-plugin" aria-label="Permalink to &quot;8. 写一个 Plugin&quot;">​</a></h2><p><strong>Plugin是一个带有apply方法的类</strong>:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">class</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> MyPlugin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  constructor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">    this</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">.options </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> options;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  apply</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compiler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    compiler.hooks.emit.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">tapAsync</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &#39;MyPlugin&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">compilation</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 在生成资源到 output 目录之前执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        compilation.assets[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;fileList.md&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          source</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;# 文件列表</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">              Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(compilation.assets).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">\\n</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1024</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">          }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        };</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">        callback</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">();</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    );</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="_9-webpack-构建速度提升" tabindex="-1">9. Webpack 构建速度提升 <a class="header-anchor" href="#_9-webpack-构建速度提升" aria-label="Permalink to &quot;9. Webpack 构建速度提升&quot;">​</a></h2><ol><li>升级Webpack版本</li></ol><ul><li>使用最新版本的Webpack</li><li>每个新版本通常都包含性能改进和优化</li></ul><ol start="2"><li>使用持久缓存</li></ol><ul><li>配置生成长期缓存的文件名</li><li>只有修改过的文件需要重新构建</li><li>可配置cache:{type:&#39;filesystem&#39;}启用文件系统缓存</li></ul><ol start="3"><li>多进程/多实例</li></ol><ul><li>使用thread-loader将任务分发给多个线程</li><li>使用HappyPack实现多进程打包</li><li>合理设置worker数量,一般是CPU核心数-1</li></ul><ol start="4"><li>DLL动态链接库</li></ol><ul><li>将React、Vue等基础包预编译为DLL</li><li>避免每次都重新编译第三方模块</li><li>开发环境作用更明显</li></ul><ol start="5"><li>缩小构建目标</li></ol><ul><li>配置最小loader规则,合理使用include/exclude</li><li>优化resolve.modules配置缩小模块搜索范围</li><li>使用noParse跳过无依赖文件解析</li></ul><ol start="6"><li>代码优化</li></ol><ul><li>开启Tree Shaking删除无用代码</li><li>使用Code Splitting按需加载</li><li>合理使用动态导入和懒加载</li></ul><ol start="7"><li>开发工具优化</li></ol><ul><li>使用webpack-dev-server启用热更新</li><li>开发环境关闭不必要的功能(压缩等)</li><li>区分开发和生产环境配置</li></ul><ol start="8"><li>分析与监控</li></ol><ul><li>使用speed-measure-webpack-plugin测量构建速度</li><li>使用webpack-bundle-analyzer分析包体积</li><li>持续监控构建性能指标</li></ul><h2 id="_10-webpack-神奇注释" tabindex="-1">10. Webpack 神奇注释 <a class="header-anchor" href="#_10-webpack-神奇注释" aria-label="Permalink to &quot;10. Webpack 神奇注释&quot;">​</a></h2><p>Webpack的&quot;神奇注释&quot;(Magic Comments)是一种特殊的注释语法，用于在Webpack打包过程中提供附加的指令和配置信息。这些注释以特殊的格式编写，并可以影响Webpack的行为。</p><ol><li>Chunk名称注释:用于动态导入的模块指定生成的Chunk文件的名称</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackChunkName: &quot;my-chunk&quot; */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./my-module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ol start="2"><li>Chunk模式注释:用于指定模块的加载模式，如&quot;lazy&quot;、&quot;lazy-once&quot;、&quot;eager&quot;等</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackMode: &quot;lazy&quot; */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./my-module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ol start="3"><li>Chunk预取注释:用于指定是否在空闲时预取模块，</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackPrefetch: true */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./my-module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><ol start="4"><li>Chunk预加载注释:用于指定是否在当前模块加载后立即预加载模块</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">/* webpackPreload: true */</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;./my-module&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre></div><h2 id="_11-webpack-分包案例" tabindex="-1">11. webpack 分包案例 <a class="header-anchor" href="#_11-webpack-分包案例" aria-label="Permalink to &quot;11. webpack 分包案例&quot;">​</a></h2><p>目的:尽量按改动频率区分，利用浏览器缓存</p><ol><li>vendor:第三方lib库，基本不会改动，除非依赖版本升级</li><li>common:业务组件代码的公共部分抽取出来，改动较少</li><li>entry:不同页面entry里业务组件代码的差异部分，会经常改动</li></ol><h2 id="_12-webpack-和-vite-的区别" tabindex="-1">12. Webpack 和 Vite 的区别 <a class="header-anchor" href="#_12-webpack-和-vite-的区别" aria-label="Permalink to &quot;12. Webpack 和 Vite 的区别&quot;">​</a></h2><p>主要区别:</p><ol><li><strong>开发环境</strong></li></ol><ul><li>Webpack: 先打包再启动开发服务器</li><li>Vite: 不打包,基于ESM的开发服务器</li></ul><ol start="2"><li><strong>构建原理</strong></li></ol><ul><li>Webpack: 构建依赖图,全量打包</li><li>Vite: 按需编译,利用浏览器ESM能力</li></ul><ol start="3"><li><strong>热更新</strong></li></ol><ul><li>Webpack: 重新构建模块</li><li>Vite: 精确定位变更模块</li></ul><h2 id="_13-babel-的原理" tabindex="-1">13. Babel 的原理 <a class="header-anchor" href="#_13-babel-的原理" aria-label="Permalink to &quot;13. Babel 的原理&quot;">​</a></h2><p>转换过程分为三个阶段:</p><ol><li><strong>解析(Parse)</strong>: 源码转换为AST</li><li><strong>转换(Transform)</strong>: 对AST进行遍历和修改</li><li><strong>生成(Generate)</strong>: AST转换为目标代码</li></ol><p>示例:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> babel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> require</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@babel/core&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> code</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> \`const sum = (a, b) =&gt; a + b\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> result</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> babel.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">transform</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(code, {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  presets: [</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;@babel/preset-env&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><h2 id="_14-模块化与组件化的区别" tabindex="-1">14. 模块化与组件化的区别 <a class="header-anchor" href="#_14-模块化与组件化的区别" aria-label="Permalink to &quot;14. 模块化与组件化的区别&quot;">​</a></h2><ul><li><p><strong>模块化</strong>: 功能维度的代码拆分</p><ul><li>关注数据和功能的封装</li><li>相对独立的功能单元</li></ul></li><li><p><strong>组件化</strong>: UI维度的代码拆分</p><ul><li>关注视图的封装</li><li>可复用的UI单元</li></ul></li></ul><h2 id="_15-commonjs与esm的区别" tabindex="-1">15. commonJS与ESM的区别 <a class="header-anchor" href="#_15-commonjs与esm的区别" aria-label="Permalink to &quot;15. commonJS与ESM的区别&quot;">​</a></h2><p>CommonJS 模块通常用于服务器端(Node.js)，在浏览器端需要使用工具进行转译或打包。 ESM(ECMAScript Modules) 模块是浏览器原生支持的，可以直接在现代浏览器中使用，不需要额外的转译工具。</p><ol><li>加载时机</li></ol><ul><li>CommonJS: 同步加载，模块在运行时(runtime)加载，并且是按需加载的，只有在需要时才会被加载</li><li>ESM: 静态加载的，模块在解析时加载，在代码执行之前就被加载，因此具有更早的加载时机</li></ul><ol start="2"><li>依赖关系</li></ol><ul><li>CommonJS: 模块的依赖关系是动态的，意味着模块可以在运行时根据条件加载不同的依赖</li><li>ESM: 模块的依赖关系是静态的，依赖关系在模块加载之前就确定，不能根据条件改变依赖关系</li></ul><ol start="3"><li>导出方式</li></ol><ul><li>CommonJS: 使用 module.exports 来导出模块，可以导出任意类型的值，包括函数、对象、类等</li><li>ESM: 使用 export 和 import 关键字来导出和导入模块。导出时需要明确指定导出的变量、函数或类，导入时也需要明确指定要导入的内容</li></ul><ol start="4"><li>作用域共享</li></ol><ul><li>CommonJS: 模块在每个模块中都有自己的作用域，不会污染全局作用域</li><li>ESM: 模块默认是严格模式(strict mode)，变量不会污染全局作用域，模块内部的变量不会被提升</li></ul><ol start="5"><li>静态分析</li></ol><ul><li>CommonJS: 模块的依赖关系无法在编译时静态分析，这对一些工具的性能和优化产生了挑战</li><li>ESM: 模块的依赖关系可以在编译时进行静态分析，这有助于提高性能和优化</li></ul><h2 id="_16-ssr与csr的理解" tabindex="-1">16. SSR与CSR的理解 <a class="header-anchor" href="#_16-ssr与csr的理解" aria-label="Permalink to &quot;16. SSR与CSR的理解&quot;">​</a></h2><ol><li>我们平常在浏览器页面，是有两种渲染方式的，一种是由浏览器渲染，叫 CSR，<code>Client-Side Rendering</code>，这也是绝大部分同学日常开发的模式。而另一种是方式则是由服务端渲染，<code>Server-Side Rendering</code>，简称 SSR。</li><li>我们日常的 CSR 渲染逻辑是后端返回一个空白 html，浏览器接收到这个 html后，再执行 vue 的初始化相关事情，再请求各个接口获取数据，最后再把数据填充在页面上。而 SSR，则是由服务端完成这一系列行为，构建好 vue，后端从数据库取出要渲染的数据并填充在页面上。这样一来，页面对 SEO 变得友好，而且减少很多页面请求数据的交互，首屏能更快的完成渲染。但又因为有更多的逻辑在渲染前完成，可能会导致白屏时间过长，服务器压力变大，页面跳转也需要频繁的刷新页面，体验不友好。</li><li>而在真实的开发中，不是非此即彼的，CSR 和 SSR 都有各自的优缺点，我自己的项目架构，往往是首屏服务器渲染，保证首页渲染速度，而次屏用浏览器渲染，保证用户体验。</li></ol><h2 id="_17-spa与mpa的优劣" tabindex="-1">17. SPA与MPA的优劣 <a class="header-anchor" href="#_17-spa与mpa的优劣" aria-label="Permalink to &quot;17. SPA与MPA的优劣&quot;">​</a></h2><h2 id="spa与mpa的理解" tabindex="-1">SPA与MPA的理解 <a class="header-anchor" href="#spa与mpa的理解" aria-label="Permalink to &quot;SPA与MPA的理解&quot;">​</a></h2><ol><li><strong>定义</strong></li></ol><ul><li><p>SPA(Single Page Application): 单页面应用</p><ul><li>不刷新页面,通过前端路由(如vue-router、react-router)实现页面跳转</li><li>整个应用只有一个HTML页面</li></ul></li><li><p>MPA(Multiple Page Application): 多页面应用</p><ul><li>通过浏览器原生的页面跳转机制</li><li>每次跳转都会刷新页面</li><li>每个页面都是独立的HTML文档</li></ul></li></ul><ol start="2"><li><strong>SPA的优缺点</strong></li></ol><p><strong>优点:</strong></p><ul><li>用户体验好,页面切换流畅</li><li>前后端分离,开发效率高</li><li>服务器压力小,只需要处理数据请求</li><li>可以实现更复杂的交互功能</li></ul><p><strong>缺点:</strong></p><ul><li>首屏加载较慢,需要加载框架和应用代码</li><li>SEO不友好,因为页面内容由JS动态生成</li><li>前端代码复杂度高</li></ul><ol start="3"><li><strong>MPA的优缺点</strong></li></ol><p><strong>优点:</strong></p><ul><li>SEO友好,每个页面都是完整的HTML</li><li>首屏加载快,只需加载当前页面资源</li><li>开发难度相对较小</li></ul><p><strong>缺点:</strong></p><ul><li>页面切换体验差,需要刷新页面</li><li>页面间难以共享数据</li><li>相同资源可能重复加载</li><li>前后端耦合度高</li></ul><ol start="4"><li><strong>如何选择</strong></li></ol><p>需要根据具体项目需求权衡:</p><ul><li><p>项目类型:</p><ul><li>内容展示类网站 -&gt; MPA</li><li>交互复杂的应用 -&gt; SPA</li></ul></li><li><p>重要考虑因素:</p><ul><li>SEO需求</li><li>首屏加载速度要求</li><li>用户体验要求</li><li>开发团队技术栈</li><li>维护成本</li></ul></li></ul>`,111),p=[t];function e(h,k,r,o,E,g){return a(),i("div",null,p)}const y=s(n,[["render",e]]);export{c as __pageData,y as default};
