import{_ as i,c as l,o as s,a5 as a}from"./chunks/framework.BIhQMg0k.js";const E=JSON.parse('{"title":"面试宝典 - TVue生态题目","description":"","frontmatter":{"title":"面试宝典 - TVue生态题目","needVerify":true,"date":"2024-12-12T00:00:00.000Z","categories":["面试","vue"]},"headers":[],"relativePath":"blogs/interview/vue生态题目.md","filePath":"blogs/interview/vue生态题目.md"}'),e={name:"blogs/interview/vue生态题目.md"},t=a(`<h1 id="vue生态题目" tabindex="-1">Vue生态题目 <a class="header-anchor" href="#vue生态题目" aria-label="Permalink to &quot;Vue生态题目&quot;">​</a></h1><h2 id="_1-vue2-不能监听数组下标的原因" tabindex="-1">1. Vue2 不能监听数组下标的原因 <a class="header-anchor" href="#_1-vue2-不能监听数组下标的原因" aria-label="Permalink to &quot;1. Vue2 不能监听数组下标的原因&quot;">​</a></h2><p>Vue2 使用 Object.defineProperty 实现数据响应式,这个 API 可以监听对象属性的读写。但对于数组,有两个主要限制:</p><ol><li>无法检测通过索引修改数组元素,如 <code>arr[1] = 2</code></li><li>无法检测数组长度的变化,如 <code>arr.length = 0</code></li></ol><p>这是因为 Object.defineProperty 只能劫持对象的属性,它并不知道什么时候通过索引给数组添加了一个新的元素。</p><p>Vue2 的解决方案是:</p><ul><li>重写了数组的 7 个变异方法: push、pop、shift、unshift、splice、sort、reverse</li><li>提供 Vue.set 方法动态添加响应式数组元素</li><li>提供 vm.$set 实例方法</li></ul><h2 id="_2-vue2-和-vue3-的具体区别" tabindex="-1">2. Vue2 和 Vue3 的具体区别 <a class="header-anchor" href="#_2-vue2-和-vue3-的具体区别" aria-label="Permalink to &quot;2. Vue2 和 Vue3 的具体区别&quot;">​</a></h2><ol><li>响应式系统</li></ol><ul><li>Vue2: Object.defineProperty,不能监听数组索引和对象新增属性</li><li>Vue3: Proxy,可以监听整个对象,包括数组索引和对象新增属性</li></ul><ol start="2"><li>性能优化</li></ol><ul><li>更小的包体积:支持 tree-shaking</li><li>更快的虚拟 DOM:静态标记(PatchFlag)</li><li>基于 Proxy 的响应式系统</li></ul><ol start="3"><li>Composition API</li></ol><ul><li>Vue2: Options API,配置式 API</li><li>Vue3: Composition API,组合式 API,更好的逻辑复用和代码组织</li></ul><ol start="4"><li>生命周期变化</li></ol><ul><li>beforeDestroy -&gt; onBeforeUnmount</li><li>destroyed -&gt; onUnmounted</li><li>所有生命周期钩子统一用 on 开头</li></ul><ol start="5"><li>其他特性</li></ol><ul><li>Teleport 传送门</li><li>Fragments 片段</li><li>Suspense 异步加载</li><li>更好的 TypeScript 支持</li></ul><h2 id="_3-vue-的通讯方式" tabindex="-1">3. Vue 的通讯方式 <a class="header-anchor" href="#_3-vue-的通讯方式" aria-label="Permalink to &quot;3. Vue 的通讯方式&quot;">​</a></h2><ol><li>父子组件通信</li></ol><ul><li>props / emit</li><li>ref / expose</li><li>v-model</li></ul><ol start="2"><li>跨层级组件通信</li></ol><ul><li>provide / inject</li><li>EventBus</li><li>Vuex/Pinia</li></ul><ol start="3"><li>兄弟组件通信</li></ol><ul><li>通过父组件中转</li><li>EventBus</li><li>Vuex/Pinia</li></ul><ol start="4"><li>全局通信</li></ol><ul><li>Vuex/Pinia 状态管理</li><li>EventBus 事件总线</li></ul><h2 id="_4-vue-的常用修饰符" tabindex="-1">4. Vue 的常用修饰符 <a class="header-anchor" href="#_4-vue-的常用修饰符" aria-label="Permalink to &quot;4. Vue 的常用修饰符&quot;">​</a></h2><ol><li>事件修饰符</li></ol><ul><li>.stop - 阻止事件冒泡</li><li>.prevent - 阻止默认行为</li><li>.capture - 使用事件捕获模式</li><li>.self - 只当事件在该元素本身触发时触发回调</li><li>.once - 事件只触发一次</li><li>.passive - 提升滚动性能</li></ul><ol start="2"><li>按键修饰符</li></ol><ul><li>.enter</li><li>.tab</li><li>.esc</li><li>.space</li><li>.ctrl</li><li>.alt</li><li>.shift</li></ul><ol start="3"><li>表单修饰符</li></ol><ul><li>.lazy - 在 change 事件后同步</li><li>.number - 自动转换为数字</li><li>.trim - 自动过滤首尾空格</li></ul><h2 id="_5-vue2-初始化过程中做了哪些事" tabindex="-1">5. Vue2 初始化过程中做了哪些事？ <a class="header-anchor" href="#_5-vue2-初始化过程中做了哪些事" aria-label="Permalink to &quot;5. Vue2 初始化过程中做了哪些事？&quot;">​</a></h2><ol><li>初始化生命周期</li></ol><ul><li>初始化事件中心</li><li>初始化渲染函数</li><li>调用 beforeCreate 钩子</li></ul><ol start="2"><li>初始化数据</li></ol><ul><li>初始化 props</li><li>初始化 methods</li><li>初始化 data</li><li>初始化 computed</li><li>初始化 watch</li><li>调用 created 钩子</li></ul><ol start="3"><li>挂载阶段</li></ol><ul><li>检查是否有 el 选项</li><li>编译模板为渲染函数</li><li>创建 Watcher 实例</li><li>首次渲染,生成虚拟 DOM</li><li>创建真实 DOM 并挂载</li><li>调用 mounted 钩子</li></ul><h2 id="_6-created-和-mounted-有什么区别" tabindex="-1">6. created 和 mounted 有什么区别？ <a class="header-anchor" href="#_6-created-和-mounted-有什么区别" aria-label="Permalink to &quot;6. created 和 mounted 有什么区别？&quot;">​</a></h2><p>created:</p><ul><li>组件实例已经创建</li><li>data 和 methods 已经初始化</li><li>还未挂载到 DOM,无法访问 $el</li><li>适合做:数据初始化,异步请求</li></ul><p>mounted:</p><ul><li>组件已经挂载到 DOM</li><li>可以访问到 $el</li><li>可以操作 DOM 元素</li><li>适合做:DOM 操作,第三方库初始化</li></ul><p>生命周期顺序: created -&gt; beforeMount -&gt; mounted</p><h2 id="_7-vue-的-nexttick-是如何实现的" tabindex="-1">7. Vue 的 $nextTick 是如何实现的 <a class="header-anchor" href="#_7-vue-的-nexttick-是如何实现的" aria-label="Permalink to &quot;7. Vue 的 $nextTick 是如何实现的&quot;">​</a></h2><p><code>$nextTick </code>是 Vue 提供的一个异步更新机制,原理如下:</p><ol><li>实现思路</li></ol><ul><li>将回调函数加入异步队列</li><li>在下一个 tick 时执行队列中的所有回调</li></ul><ol start="2"><li>异步执行优先级</li></ol><ul><li>Promise</li><li>MutationObserver</li><li>setImmediate</li><li>setTimeout</li></ul><ol start="3"><li>使用场景</li></ol><ul><li>DOM 更新后获取新的 DOM 节点</li><li>获取更新后的 DOM 尺寸</li><li>在数据变化后执行某些操作</li></ul><h2 id="_8-为什么-vue-中的-data-是一个函数而不是普通-object" tabindex="-1">8. 为什么 vue 中的 data 是一个函数而不是普通 object？ <a class="header-anchor" href="#_8-为什么-vue-中的-data-是一个函数而不是普通-object" aria-label="Permalink to &quot;8. 为什么 vue 中的 data 是一个函数而不是普通 object？&quot;">​</a></h2><p>原因:</p><ol><li>组件可能被复用,如果 data 是对象,则所有实例共享同一个对象</li><li>data 是函数时,每个实例可以维护一份被返回对象的独立拷贝</li><li>这样组件实例之间不会互相影响</li></ol><h2 id="_9-vue-的父组件和子组件生命周期钩子的执行顺序" tabindex="-1">9. Vue 的父组件和子组件生命周期钩子的执行顺序 <a class="header-anchor" href="#_9-vue-的父组件和子组件生命周期钩子的执行顺序" aria-label="Permalink to &quot;9. Vue 的父组件和子组件生命周期钩子的执行顺序&quot;">​</a></h2><p>加载渲染过程:</p><ol><li>父 beforeCreate</li><li>父 created</li><li>父 beforeMount</li><li>子 beforeCreate</li><li>子 created</li><li>子 beforeMount</li><li>子 mounted</li><li>父 mounted</li></ol><p>更新过程:</p><ol><li>父 beforeUpdate</li><li>子 beforeUpdate</li><li>子 updated</li><li>父 updated</li></ol><p>销毁过程:</p><ol><li>父 beforeDestroy</li><li>子 beforeDestroy</li><li>子 destroyed</li><li>父 destroyed</li></ol><h2 id="_10-watch-和-computed-有什么区别" tabindex="-1">10. watch 和 computed 有什么区别？ <a class="header-anchor" href="#_10-watch-和-computed-有什么区别" aria-label="Permalink to &quot;10. watch 和 computed 有什么区别？&quot;">​</a></h2><p>computed:</p><ul><li>有缓存机制,依赖不变时直接返回缓存值</li><li>必须有返回值</li><li>适合做依赖数据的计算</li></ul><p>watch:</p><ul><li>无缓存,数据变化时就会执行</li><li>不需要返回值</li><li>适合执行异步操作或开销较大的操作</li></ul><p>使用场景:</p><ul><li>computed: 处理模板中的复杂逻辑</li><li>watch: 监听数据变化执行异步操作</li></ul><h2 id="_11-谈谈-computed-的机制-缓存了什么" tabindex="-1">11. 谈谈 computed 的机制，缓存了什么？ <a class="header-anchor" href="#_11-谈谈-computed-的机制-缓存了什么" aria-label="Permalink to &quot;11. 谈谈 computed 的机制，缓存了什么？&quot;">​</a></h2><p>computed 的实现机制:</p><ol><li>初始化时为每个计算属性创建一个 Watcher</li><li>Watcher 记录计算属性的依赖(data 中的响应式数据)</li><li>首次访问计算属性时执行计算,缓存计算结果</li><li>依赖项变化时,标记缓存为脏数据</li><li>再次访问时,如果缓存是脏的则重新计算</li></ol><p>缓存内容:</p><ul><li>计算结果值</li><li>标记缓存是否为脏数据的 dirty 属性</li><li>收集的依赖关系</li></ul><h2 id="_12-为什么-computed-不支持异步" tabindex="-1">12. 为什么 computed 不支持异步? <a class="header-anchor" href="#_12-为什么-computed-不支持异步" aria-label="Permalink to &quot;12. 为什么 computed 不支持异步?&quot;">​</a></h2><p>原因:</p><ol><li>computed 必须同步返回结果用于渲染</li><li>异步操作无法立即返回值</li><li>异步操作的结果何时回来是不确定的</li><li>违背 computed immediate 和 lazy 的设计理念</li></ol><p>解决方案:</p><ol><li>使用 watch 处理异步操作</li><li>使用 async/await 配合 ref 响应式数据</li></ol><h2 id="_13-vue3-dom-diff-算法" tabindex="-1">13. Vue3 DOM Diff 算法 <a class="header-anchor" href="#_13-vue3-dom-diff-算法" aria-label="Permalink to &quot;13. Vue3 DOM Diff 算法&quot;">​</a></h2><p>Vue3 的 Diff 算法主要优化:</p><ol><li>静态标记(PatchFlag)</li></ol><ul><li>标记动态节点</li><li>跳过静态节点比较</li><li>减少 Diff 次数</li></ul><ol start="2"><li>最长递增子序列</li></ol><ul><li>优化节点移动</li><li>减少 DOM 操作</li><li>提高性能</li></ul><ol start="3"><li>Block Tree</li></ol><ul><li>收集动态节点</li><li>减少遍历范围</li><li>提高更新性能</li></ul><ol start="4"><li>双端比较</li></ol><ul><li>从两端向中间比较</li><li>减少比较次数</li><li>优化节点复用</li></ul><h2 id="_14-vue3-的最长递增子序列算法" tabindex="-1">14. Vue3 的最长递增子序列算法 <a class="header-anchor" href="#_14-vue3-的最长递增子序列算法" aria-label="Permalink to &quot;14. Vue3 的最长递增子序列算法&quot;">​</a></h2><p>作用:</p><ul><li>优化节点移动</li><li>找出可复用的节点序列</li><li>最小化 DOM 操作</li></ul><p>实现步骤:</p><ol><li>构建新旧节点索引映射</li><li>标记需要移动的节点</li><li>计算最长递增子序列</li><li>根据序列移动节点</li></ol><p>优化效果:</p><ul><li>减少节点移动次数</li><li>提高 Diff 效率</li><li>优化渲染性能</li></ul><h2 id="_15-vue3-中-ref-和-reactive-的区别" tabindex="-1">15. vue3 中 ref 和 reactive 的区别 <a class="header-anchor" href="#_15-vue3-中-ref-和-reactive-的区别" aria-label="Permalink to &quot;15. vue3 中 ref 和 reactive 的区别&quot;">​</a></h2><p>ref:</p><ul><li>可以包装基本类型</li><li>需要通过 .value 访问</li><li>自动解包模板引用</li><li>单一值的响应式</li></ul><p>reactive:</p><ul><li>只能包装对象类型</li><li>直接访问属性</li><li>深层响应式</li><li>对象的响应式</li></ul><p>使用建议:</p><ul><li>基本类型用 ref</li><li>对象类型用 reactive</li><li>保持响应式风格统一</li></ul><h2 id="_16-vue3-区分-ref-和-reactive-的原因" tabindex="-1">16. vue3 区分 ref 和 reactive 的原因 <a class="header-anchor" href="#_16-vue3-区分-ref-和-reactive-的原因" aria-label="Permalink to &quot;16. vue3 区分 ref 和 reactive 的原因&quot;">​</a></h2><p>设计原因:</p><ol><li>类型处理</li></ol><ul><li>ref 处理基本类型</li><li>reactive 处理对象类型</li><li>更清晰的类型区分</li></ul><ol start="2"><li>使用场景</li></ol><ul><li>ref 适合单值响应</li><li>reactive 适合对象响应</li><li>不同场景最优解</li></ul><ol start="3"><li>实现机制</li></ol><ul><li>ref 基于 get/set</li><li>reactive 基于 Proxy</li><li>性能和功能考虑</li></ul><ol start="4"><li>开发体验</li></ol><ul><li>更直观的 API 设计</li><li>更好的类型推导</li><li>更清晰的代码意图</li></ul><h2 id="_17-vue-响应式-observer、dep、watcher" tabindex="-1">17. Vue 响应式 Observer、Dep、Watcher <a class="header-anchor" href="#_17-vue-响应式-observer、dep、watcher" aria-label="Permalink to &quot;17. Vue 响应式 Observer、Dep、Watcher&quot;">​</a></h2><p>核心概念:</p><ol><li>Observer</li></ol><ul><li>将数据转换为响应式</li><li>监听属性变化</li><li>通知依赖更新</li></ul><ol start="2"><li>Dep</li></ol><ul><li>管理 Watcher 依赖</li><li>收集依赖</li><li>触发更新</li></ul><ol start="3"><li>Watcher</li></ol><ul><li>订阅数据变化</li><li>执行更新函数</li><li>触发视图更新</li></ul><p>工作流程:</p><ol><li>Observer 劫持数据</li><li>Dep 收集依赖</li><li>数据变化通知 Watcher</li><li>Watcher 触发更新</li></ol><h2 id="_18-vue3-为什么要用-proxy-替换-object-defineproperty" tabindex="-1">18. vue3 为什么要用 proxy 替换 Object.defineProperty? <a class="header-anchor" href="#_18-vue3-为什么要用-proxy-替换-object-defineproperty" aria-label="Permalink to &quot;18. vue3 为什么要用 proxy 替换 Object.defineProperty?&quot;">​</a></h2><p>主要原因:</p><ol><li>功能完整性</li></ol><ul><li>可以监听数组变化</li><li>可以监听对象新增属性</li><li>可以监听删除属性</li></ul><ol start="2"><li>性能优化</li></ol><ul><li>不需要递归遍历</li><li>懒处理属性</li><li>更好的性能</li></ul><ol start="3"><li>实现机制</li></ol><ul><li>代理整个对象</li><li>更简洁的代码</li><li>更好的可维护性</li></ul><ol start="4"><li>语言特性</li></ol><ul><li>ES6+ 标准特性</li><li>更强大的代理能力</li><li>更好的未来兼容性</li></ul><h2 id="_19-什么是虚拟-dom" tabindex="-1">19. 什么是虚拟 DOM <a class="header-anchor" href="#_19-什么是虚拟-dom" aria-label="Permalink to &quot;19. 什么是虚拟 DOM&quot;">​</a></h2><p>概念:</p><ul><li>JavaScript 对象描述 DOM</li><li>内存中的 DOM 表示</li><li>用于优化 DOM 操作</li></ul><p>优势:</p><ol><li>性能优化</li></ol><ul><li>批量 DOM 更新</li><li>减少重排重绘</li><li>跨平台能力</li></ul><ol start="2"><li>实现原理</li></ol><ul><li>创建虚拟节点</li><li>Diff 算法比较</li><li>最小化 DOM 操作</li></ul><ol start="3"><li>应用场景</li></ol><ul><li>框架底层实现</li><li>跨平台开发</li><li>服务端渲染</li></ul><h2 id="_20-vue2-的生命周期" tabindex="-1">20. vue2 的生命周期 <a class="header-anchor" href="#_20-vue2-的生命周期" aria-label="Permalink to &quot;20. vue2 的生命周期&quot;">​</a></h2><p>完整生命周期:</p><ol><li>创建阶段</li></ol><ul><li>beforeCreate</li><li>created</li></ul><ol start="2"><li>挂载阶段</li></ol><ul><li>beforeMount</li><li>mounted</li></ul><ol start="3"><li>更新阶段</li></ol><ul><li>beforeUpdate</li><li>updated</li></ul><ol start="4"><li>销毁阶段</li></ol><ul><li>beforeDestroy</li><li>destroyed</li></ul><p>特殊生命周期:</p><ul><li>activated (keep-alive)</li><li>deactivated (keep-alive)</li><li>errorCaptured (错误捕获)</li></ul><h2 id="_21-vue3-生命周期" tabindex="-1">21. vue3 生命周期 <a class="header-anchor" href="#_21-vue3-生命周期" aria-label="Permalink to &quot;21. vue3 生命周期&quot;">​</a></h2><p>Composition API 生命周期:</p><ol><li>创建阶段</li></ol><ul><li>setup()</li><li>onBeforeMount</li><li>onMounted</li></ul><ol start="2"><li>更新阶段</li></ol><ul><li>onBeforeUpdate</li><li>onUpdated</li></ul><ol start="3"><li>销毁阶段</li></ol><ul><li>onBeforeUnmount</li><li>onUnmounted</li></ul><ol start="4"><li>其他钩子</li></ol><ul><li>onActivated</li><li>onDeactivated</li><li>onErrorCaptured</li></ul><p>主要变化:</p><ul><li>setup 替代 beforeCreate 和 created</li><li>生命周期钩子统一用 on 开头</li><li>在 setup 中注册</li></ul><h2 id="_22-watch-怎么深度监听对象变化" tabindex="-1">22. watch 怎么深度监听对象变化 <a class="header-anchor" href="#_22-watch-怎么深度监听对象变化" aria-label="Permalink to &quot;22. watch 怎么深度监听对象变化&quot;">​</a></h2><p>实现方式:</p><ol><li>Vue2 中</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  obj</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    handler</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(newVal, oldVal) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 处理变化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    },</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    deep</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    immediate</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><ol start="2"><li>Vue3 中</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">newVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">oldVal</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 处理变化</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, { deep: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或使用 watchEffect</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watchEffect</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj.someDeepProp)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><p>注意事项:</p><ul><li>deep 会监听所有嵌套属性</li><li>可能影响性能</li><li>考虑使用具体路径监听</li></ul><h2 id="_23-vue2-删除数组用-delete-和-vue-delete-有什么区别" tabindex="-1">23. vue2 删除数组用 delete 和 Vue.delete 有什么区别? <a class="header-anchor" href="#_23-vue2-删除数组用-delete-和-vue-delete-有什么区别" aria-label="Permalink to &quot;23. vue2 删除数组用 delete 和 Vue.delete 有什么区别?&quot;">​</a></h2><p>delete 操作符:</p><ul><li>删除属性但不触发响应式</li><li>不会重新索引数组</li><li>留下空槽</li></ul><p>Vue.delete:</p><ul><li>删除属性并触发响应式更新</li><li>正确处理数组长度</li><li>重新索引数组</li></ul><p>最佳实践:</p><ul><li>数组操作用 Vue.delete</li><li>或使用数组变异方法 splice</li><li>避免使用 delete 操作符</li></ul><h2 id="_24-vue3-0-编译做了哪些优化" tabindex="-1">24. Vue3.0 编译做了哪些优化? <a class="header-anchor" href="#_24-vue3-0-编译做了哪些优化" aria-label="Permalink to &quot;24. Vue3.0 编译做了哪些优化?&quot;">​</a></h2><p>主要优化:</p><ol><li>静态提升</li></ol><ul><li>提升静态节点</li><li>减少创建开销</li><li>优化内存占用</li></ul><ol start="2"><li>补丁标记</li></ol><ul><li>标记动态节点</li><li>跳过静态节点</li><li>优化 Diff 效率</li></ul><ol start="3"><li>事件缓存</li></ol><ul><li>缓存事件处理函数</li><li>减少重新创建</li><li>优化内存使用</li></ul><ol start="4"><li>块树结构</li></ol><ul><li>收集动态节点</li><li>优化更新性能</li><li>减少遍历开销</li></ul><h2 id="_25-vue3-0-composition-api-与-react-hooks-的异同点" tabindex="-1">25. Vue3.0 Composition API 与 React Hooks 的异同点 <a class="header-anchor" href="#_25-vue3-0-composition-api-与-react-hooks-的异同点" aria-label="Permalink to &quot;25. Vue3.0 Composition API 与 React Hooks 的异同点&quot;">​</a></h2><p>相同点:</p><ol><li>逻辑复用</li></ol><ul><li>提取公共逻辑</li><li>更好的代码组织</li><li>功能模块化</li></ul><ol start="2"><li>生命周期</li></ol><ul><li>类似的钩子函数</li><li>相似的使用方式</li><li>统一的设计理念</li></ul><p>不同点:</p><ol><li>执行时机</li></ol><ul><li>Vue: setup 只执行一次</li><li>React: 每次渲染都执行</li></ul><ol start="2"><li>响应式系统</li></ol><ul><li>Vue: 自动追踪依赖</li><li>React: 手动声明依赖</li></ul><ol start="3"><li>性能优化</li></ol><ul><li>Vue: 自动优化</li><li>React: 需要手动优化</li></ul><h2 id="_26-vue-要做权限管理该怎么做-如果控制到按钮级别的权限怎么做" tabindex="-1">26. vue 要做权限管理该怎么做?如果控制到按钮级别的权限怎么做? <a class="header-anchor" href="#_26-vue-要做权限管理该怎么做-如果控制到按钮级别的权限怎么做" aria-label="Permalink to &quot;26. vue 要做权限管理该怎么做?如果控制到按钮级别的权限怎么做?&quot;">​</a></h2><p>实现方案:</p><ol><li>路由权限</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 路由守卫</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">router.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">beforeEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">to</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">from</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasPermission</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(to.meta.roles)) {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    next</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;/403&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ol start="2"><li>组件权限</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 自定义指令</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Vue.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">directive</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;permission&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  mounted</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">el</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">binding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">hasPermission</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(binding.value)) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      el.parentNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">removeChild</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(el)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre></div><ol start="3"><li>按钮权限</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 使用指令</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-permission</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;[&#39;admin&#39;]&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;删除&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 或使用函数</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-if</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;$hasPermission(&#39;delete&#39;)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;删除&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>最佳实践:</p><ul><li>结合 Vuex 管理权限状态</li><li>动态路由配置</li><li>指令和函数结合使用</li></ul><h2 id="_27-vue3-5-更新-props-响应式更新" tabindex="-1">27. Vue3.5 更新-Props 响应式更新 <a class="header-anchor" href="#_27-vue3-5-更新-props-响应式更新" aria-label="Permalink to &quot;27. Vue3.5 更新-Props 响应式更新&quot;">​</a></h2><p>Vue 3.5 的 Props 更新:</p><ol><li>新特性</li></ol><ul><li>更细粒度的响应式</li><li>更好的性能优化</li><li>更强的类型支持</li></ul><ol start="2"><li>实现优化</li></ol><ul><li>避免不必要的更新</li><li>优化 props 传递</li><li>减少重渲染</li></ul><ol start="3"><li>使用建议</li></ol><ul><li>使用 defineProps</li><li>明确类型定义</li><li>遵循单向数据流</li></ul><h2 id="_28-vue3-5-更新-usetemplateref" tabindex="-1">28. Vue3.5 更新-useTemplateRef <a class="header-anchor" href="#_28-vue3-5-更新-usetemplateref" aria-label="Permalink to &quot;28. Vue3.5 更新-useTemplateRef&quot;">​</a></h2><p>useTemplateRef 新特性:</p><ol><li>基本用法</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> inputRef</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 模板中</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ref</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;inputRef&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span></code></pre></div><ol start="2"><li>优势</li></ol><ul><li>更简洁的 ref 获取</li><li>更好的类型推导</li><li>更直观的使用方式</li></ul><ol start="3"><li>注意事项</li></ol><ul><li>需要在 mounted 后访问</li><li>可能为 null</li><li>考虑生命周期</li></ul><h2 id="_29-vue3-5-更新-watch-deep" tabindex="-1">29. Vue3.5 更新-watch deep <a class="header-anchor" href="#_29-vue3-5-更新-watch-deep" aria-label="Permalink to &quot;29. Vue3.5 更新-watch deep&quot;">​</a></h2><p>watch deep 优化:</p><ol><li>性能提升</li></ol><ul><li>更智能的依赖收集</li><li>更高效的深度监听</li><li>更好的内存使用</li></ul><ol start="2"><li>使用方式</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 深度监听</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(source, callback, { deep: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> })</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 指定路径监听</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">watch</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj.deep.prop, callback)</span></span></code></pre></div><ol start="3"><li>最佳实践</li></ol><ul><li>避免不必要的深度监听</li><li>优先使用具体路径监听</li><li>考虑性能影响</li></ul>`,242),n=[t];function h(p,o,r,u,k,d){return s(),l("div",null,n)}const g=i(e,[["render",h]]);export{E as __pageData,g as default};
