import{_ as t,D as k,c as p,l as s,I as l,w as h,a as i,a5 as a,o as e}from"./chunks/framework.Bx-mEslM.js";const E="/assets/04.8k_Vx70s.png",r="/assets/02.C_pDwkw9.png",d="/assets/03.S28gjJfa.jpg",g="/assets/01.BgMAgCvX.png",Rs=JSON.parse('{"title":"React学习笔记","description":"","frontmatter":{"title":"React学习笔记","date":"2023-5-8","categories":["react","笔记"]},"headers":[],"relativePath":"blogs/note/react.md","filePath":"blogs/note/react.md"}'),y={name:"blogs/note/react.md"},c=a("",4),o=s("li",null,[s("p",null,[s("strong",null,"MVC与MVVM")]),s("ol",null,[s("li",null,"React采用的是MVC体系，Vue采取的是MVVM体系"),s("li",null,[i("MVC：model数据层 + view视图层 + controller控制层 （单向数据驱动视图） "),s("ul",null,[s("li",null,"我们需要按照专业的语法去构建视图（页面）：react中是基于jsx语法来构建视图的"),s("li",null,"构建数据层：但凡在视图中，需要'动态'处理的（获取需要变化的，不论是样式还是内容），我们都要有对应的数据模型"),s("li",null,"控制层：当我们在视图中进行某些操作时，修改了相关数据，react会根据最新的数据重新渲染")])]),s("li",null,"MVVM：model数据层 + view视图层 + viewModel数据/视图监听层 （双向数据驱动视图）")])],-1),F=s("p",null,[s("strong",null,"JSX构建视图的基本知识（javascript and xml）")],-1),A=a("",4),D=s("li",null,[s("code",null,"number/string"),i("：直接渲染值")],-1),C=s("li",null,[s("code",null,"Boolean/null/undefined/Symbol/Bigint"),i(":渲染内容是空")],-1),u=s("li",null,[i("对象：一般不支持渲染，也有特殊情况 "),s("ul",null,[s("li",null,[i("JSX虚拟DOM对象"),s("code",null,"{React.createElement('button',null,'提交')}")]),s("li",null,"给元素设置style行内样式，要求必须写成一个对象格式")])],-1),B=s("li",null,[i("函数对象：不支持在"),s("code",null,"{}"),i("中渲染，但是可以作为函数组件，用"),s("code",null,"<Component/>"),i("方式渲染")],-1),m=a("",2),v=a("",1),f=a("",4),b=a("",1),_=a("",3),x={start:"3"},S=a("",4),R=s("p",null,"ref",-1),q=s("li",null,[s("p",null,"应用场景： 1. 管理焦点，文本选择或媒体播放。 2. 触发强制动画。 3. 集成第三方 DOM 库。")],-1),P=s("strong",null,"给类组件设置ref，获取的是当前组件的实例",-1),T=s("br",null,null,-1),j=s("code",null,"ref='xxx'",-1),N=s("code",null,"this.refs.xxx",-1),w=s("br",null,null,-1),M=s("code",null,"ref ={x=>this.xxx = x}",-1),V=s("code",null,"this.xxx",-1),O=s("code",null,"xxx = React.createRef()",-1),I=s("code",null,"{current:null}",-1),U=s("code",null,"ref = {xxx}",-1),H=s("code",null,"this.xxx.current",-1),L=s("a",{href:"//React.createRef",target:"_blank",rel:"noreferrer"},"//React.createRef",-1),z={ref:"{this.ref1}"},J={ref:"ref2"},X=s("br",null,null,-1),W=s("pre",null,[s("code",null,"      }  \n```\n")],-1),$=s("li",null,[s("p",null,[s("strong",null,"以上三种使用ref方式不能在函数组件上使用，因为函数组件没有实例"),i(" 1. 可以将该组件转化为 class 组件 2. 可以使用 "),s("code",null,"React.forwardRef"),i("实现ref的转发（可与 "),s("code",null,"useImperativeHandle"),i(" 结合使用） 3. 在函数组件 使用useRef "),s("code",null,"js const Child = React.forwardRef((props,ref)=>{ return <button ref={ref}></button> }) //父组件 render(){ return <Child ref={x=>this.child = x}></Child> }/// console.log(this.child) ")])],-1),Q=s("li",null,[s("p",null,"在HOC中转发ref + 这个技巧对高阶组件（HOC）特别有用（接受一个组件，返回一个组件的函数） ```js function logProps(WrapperdComponent){ class LogProps extends React.Component{ componentDidUpdate(prevProps){"),s("pre",null,[s("code",null,`                  }
                  render(){
                        return <WrapperdComponent {...this.props}/>
                  }
            }
            return LogProps
      }

      function logProps(WrapperdComponent){
            class LogProps extends React.Component{
                  componentDidUpdate(prevProps){

                  }
                  render(){
                        const {forwardedRef , ...rest} = this.props
                        return <WrapperdComponent ref={forwardedRef} {...rest}/>
                  }
            }
            return React.forwardRef((props,ref)=>{
                  return <LogProps {...props} forwardedRef={ref}/>
            })
      }
\`\`\`
`)])],-1),Y=a("",5),K={start:"4"},G=s("p",null,[s("strong",null,"异步更新")],-1),Z=s("li",null,[i("在"),s("code",null,"React18"),i("中，产生的私有上下文中，遇到"),s("code",null,"setState"),i(",不会立即更新状态和视图，而是加入到更新队列"),s("code",null,"updaterQueue"),i("中。")],-1),ss=s("li",null,"当上下文中代码都处理完毕后，会让更新队列中的任务，统一渲染/更新一次（批处理）",-1),is=s("li",null,"能够有效减少更新次数，降低性能消耗，有效管理代码执行的逻辑顺序",-1),as=s("code",null,"React18",-1),ns=s("code",null,"React16",-1),ls=s("code",null,"setState",-1),hs=s("br",null,null,-1),ts=s("strong",null,[i("在"),s("code",null,"React18"),i("中，不论什么地方，都是异步的，基于"),s("code",null,"updaterQueue"),i("处理机制实现批处理")],-1),ks=s("br",null,null,-1),ps=s("strong",null,[i("在"),s("code",null,"React16"),i("中，在合成事件（On绑定事件），周期函数中，"),s("code",null,"setState"),i("是异步的，但是如果"),s("code",null,"setState"),i("出现在其他异步操作中，比如定时器，手动获取DOM元素做的事件绑定，它将变为同步的操作（立即更新状态和视图渲染）")],-1),es=a("",1),Es=a("",1),rs=a("",4),ds=a("",2),gs=a("",3),ys=s("h3",{id:"useeffect",tabindex:"-1"},[s("strong",null,"useEffect"),i(),s("a",{class:"header-anchor",href:"#useeffect","aria-label":'Permalink to "**useEffect**"'},"​")],-1),cs=a("",2),os=s("p",null,[s("strong",null,"useEffect细节")],-1),Fs=s("code",null,"useEffect",-1),As=a("",1),Ds=a("",1),Cs=a("",2),us=a("",32);function Bs(ms,vs,fs,bs,_s,xs){const n=k("font");return e(),p("div",null,[c,s("ol",null,[o,s("li",null,[F,s("ol",null,[A,s("li",null,[s("strong",null,[l(n,{color:"red"},{default:h(()=>[i("胡子语法中嵌入不同的值，所呈现的特点")]),_:1})]),s("ol",null,[D,C,u,s("li",null,[i("数组对象：把数组每一项分别拿出来渲染，"),s("strong",null,[l(n,{color:"red"},{default:h(()=>[i("并不是变为字符串渲染，中间没有逗号")]),_:1})])]),B])]),m])]),v]),f,s("ol",null,[b,s("li",null,[_,s("ol",x,[S,s("li",null,[R,s("ul",null,[q,s("li",null,[s("p",null,[i("基于ref获取DOM的语法 "),P,T,i(" 1. string ref(废弃) : 元素设置"),j,i(",通过"),N,i("来获取"),w,i(" 2. callback ref : 把ref属性设置为一个函数"),M,i("，直接通过"),V,i("来获取（推荐） 3. React.createRef() : 基于"),O,i("创建一个对象-->"),I,i(",设置"),U,i(",通过"),H,i("来获取 ```js class Parent extends React.Component{ constructor(props){ super(props) this.ref1 = React.createRef() //{current:null} } componentDidMount(){ console.log(this.ref1) "),L,i("() -- {current:div} console.log(this.refs.ref2) //string ref(废弃) console.log(this.ref3) //callback ref 这个也可以用作父组件拿子组件的ref } render(){ return ( "),s("div",null,[s("div",z,null,512),s("div",J,null,512),X,i(" <div ref={ele=>this.ref3 = ele} /> ")]),i(" ) }")]),W]),$,Q])])])])]),Y,s("ol",K,[s("li",null,[G,s("ul",null,[Z,ss,is,s("li",null,[s("strong",null,[l(n,{color:"red"},{default:h(()=>[i("在"),as,i("和"),ns,i("中，关于"),ls,i("的区别")]),_:1})]),hs,i(" + "),ts,ks,i(" + "),ps])])]),es,s("li",null,[s("p",null,[s("strong",null,[l(n,{color:"red"},{default:h(()=>[i("短时间内多次修改state的同一值的问题")]),_:1})])]),Es])]),rs,s("ol",null,[s("li",null,[s("p",null,[s("strong",null,[l(n,{color:"red"},{default:h(()=>[i("useState")]),_:1})]),i("：目的是在函数组件中使用状态，并且后期基于状态的修改，可以让组件更新")]),ds]),gs]),ys,s("ol",null,[s("li",null,[s("p",null,[s("strong",null,[l(n,{color:"red"},{default:h(()=>[i("作用：在函数组件中，使用生命周期函数,遇到修改某个状态后（视图更新后），想要依赖新数据做一些事情，不能直接在代码下面编写，只能在新闭包中获取新值，也就是基于useEffect设置状态的依赖，去执行!!!!")]),_:1})])])]),cs,s("li",null,[os,s("ol",null,[s("li",null,[s("strong",null,[l(n,{color:"red"},{default:h(()=>[Fs,i("必须在函数的最外层上下文中调用")]),_:1})]),i("，不能把其嵌入到条件判断、循环等操作语句中"),As]),Ds])]),Cs]),us])}const qs=t(y,[["render",Bs]]);export{Rs as __pageData,qs as default};
