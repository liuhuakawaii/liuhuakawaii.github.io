import{_ as s,c as i,o as a,a7 as n}from"./chunks/framework.DLSH1pMh.js";const y=JSON.parse('{"title":"2-两数相加","description":"","frontmatter":{"title":"2-两数相加","date":"2026-02-05T00:00:00.000Z","categories":["leetcode"],"tags":["数据结构","JavaScript","前端进阶","算法"]},"headers":[],"relativePath":"blogs/leetcode/1-100/2-两数相加.md","filePath":"blogs/leetcode/1-100/2-两数相加.md"}'),l={name:"blogs/leetcode/1-100/2-两数相加.md"},h=n(`<h1 id="两数相加" tabindex="-1"><a href="https://leetcode.cn/problems/add-two-numbers/" target="_blank" rel="noreferrer">两数相加</a> <a class="header-anchor" href="#两数相加" aria-label="Permalink to &quot;[两数相加](https://leetcode.cn/problems/add-two-numbers/)&quot;">​</a></h1><p>这道题很有意思，它用链表来表示数字，而且是<strong>逆序存储</strong>的。也就是说，个位在链表头部，高位在尾部。比如 <code>[2, 4, 3]</code> 表示数字 342（不是 243）。</p><p>题目要求把两个这样的链表相加，返回一个新的链表。关键点：两个链表长度可能不同，可能有进位，最后可能还有进位（比如 99 + 1 = 100，需要多一个节点）。</p><h2 id="最直观的想法" tabindex="-1">最直观的想法 <a class="header-anchor" href="#最直观的想法" aria-label="Permalink to &quot;最直观的想法&quot;">​</a></h2><p>第一次看到这题，我想到的是：先把两个链表转成数字，相加后再转回链表。</p><p>遍历链表1，从个位开始：<code>num1 = 2 + 4*10 + 3*100 = 342</code>。同样方法转链表2，相加，再把结果转回链表。</p><p>这个方法思路简单，但有个致命问题：<strong>数字溢出</strong>。如果链表有 100 个节点，每个节点都是 9，数字就是 10^100 - 1，JavaScript 的 Number 类型无法精确表示这么大的数。</p><p>而且，题目用链表存储就是为了避免大数问题，我们应该直接操作链表，而不是转成数字。</p><h2 id="换个思路-模拟加法" tabindex="-1">换个思路：模拟加法 <a class="header-anchor" href="#换个思路-模拟加法" aria-label="Permalink to &quot;换个思路：模拟加法&quot;">​</a></h2><p>既然不能转成数字，那就直接操作链表，模拟小学做加法的过程：从个位开始，逐位相加，处理进位。</p><p>我们可以同时遍历两个链表，用两个指针分别指向当前位。计算当前位时：</p><ul><li>当前位的值 = (l1.val + l2.val + carry) % 10</li><li>进位 = Math.floor((l1.val + l2.val + carry) / 10)</li></ul><p>如果某个链表遍历完了，用 0 代替。如果最后还有进位，需要多创建一个节点。</p><p>这里有个技巧：用<strong>虚拟头节点（Dummy Head）</strong>。这样构建新链表时，不用特判第一个节点，所有节点都用 <code>cur.next = new ListNode(...)</code> 添加，最后返回 <code>dummy.next</code> 即可。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> addTwoNumbers</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">l1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">l2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> dummy</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> carry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 循环条件：l1 不为空 或 l2 不为空 或 还有进位</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 注意：即使两个链表都遍历完了，如果还有进位，需要继续</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    while</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (l1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> carry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">!==</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> v1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l1.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> v2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l2.val </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">:</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> sum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> v2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> carry</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        carry </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> Math.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">floor</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">/</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> digit</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> sum </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">%</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 10</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cur.next </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> ListNode</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(digit)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        cur </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> cur.next</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (l1) l1 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l1.next</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (l2) l2 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> l2.next</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> dummy.next</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><h2 id="为什么用虚拟头节点" tabindex="-1">为什么用虚拟头节点？ <a class="header-anchor" href="#为什么用虚拟头节点" aria-label="Permalink to &quot;为什么用虚拟头节点？&quot;">​</a></h2><p>虚拟头节点可以简化代码。如果没有它，我们需要特判&quot;第一个节点&quot;，代码会变得复杂。有了虚拟头节点，所有节点都用统一的方式添加，最后跳过虚拟头节点返回即可。</p><p>这是链表操作的一个常见技巧，在很多题目中都会用到。</p><h2 id="边界情况" tabindex="-1">边界情况 <a class="header-anchor" href="#边界情况" aria-label="Permalink to &quot;边界情况&quot;">​</a></h2><p>有几个边界情况需要注意：</p><ol><li>两个链表长度不同：用 0 代替已遍历完的链表的值</li><li>最后还有进位：循环条件要检查 <code>carry !== 0</code></li><li>空链表：题目说非空，但代码中还是要注意 null 检查</li></ol><h2 id="这道题在考什么" tabindex="-1">这道题在考什么？ <a class="header-anchor" href="#这道题在考什么" aria-label="Permalink to &quot;这道题在考什么？&quot;">​</a></h2><p>这道题的核心是<strong>链表的操作</strong>和<strong>模拟计算过程</strong>。我们需要：</p><ul><li>同时遍历多个链表</li><li>处理进位</li><li>构建新链表</li></ul><p>虚拟头节点是链表操作的一个经典技巧，可以简化代码，避免特判。</p><p>下次遇到类似题目，看到&quot;链表&quot;、&quot;逐位处理&quot;、&quot;加法&quot;、&quot;进位&quot;这些关键词，就应该想到这种思路。比如字符串相加、二进制求和这些题，虽然操作的是字符串或二进制，但思路是一样的。</p><p><strong>记忆要点：</strong></p><ul><li>链表操作 → 虚拟头节点</li><li>逐位相加 → 模拟计算过程</li><li>处理进位 → 最后可能还有进位</li></ul>`,28),t=[h];function k(p,e,r,d,E,g){return a(),i("div",null,t)}const c=s(l,[["render",k]]);export{y as __pageData,c as default};
