import{_ as s,c as a,o as i,a7 as n}from"./chunks/framework.DLSH1pMh.js";const E=JSON.parse('{"title":"6-Z 字形变换","description":"","frontmatter":{"title":"6-Z 字形变换","date":"2026-02-06T00:00:00.000Z","categories":["leetcode"],"tags":["字符串","模拟","JavaScript","算法"]},"headers":[],"relativePath":"blogs/leetcode/1-100/6-Z字形变换.md","filePath":"blogs/leetcode/1-100/6-Z字形变换.md"}'),p={name:"blogs/leetcode/1-100/6-Z字形变换.md"},l=n(`<h1 id="z-字形变换" tabindex="-1"><a href="https://leetcode.cn/problems/zigzag-conversion/" target="_blank" rel="noreferrer">Z 字形变换</a> <a class="header-anchor" href="#z-字形变换" aria-label="Permalink to &quot;[Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/)&quot;">​</a></h1><p>这题的名字听起来有点抽象，但本质上是一个字符串重排问题：给你一个字符串 <code>s</code> 和一个行数 <code>numRows</code>，让你按照「Z 字形」写在纸上，再按行读出来，返回新的字符串。</p><p><code>numRows</code> 是一行一行往下写，写到最后一行后折返往上写，如此之字形往复。最后你不是按「走的路径」读，而是<strong>按行从上到下读</strong>。</p><p>有几个容易踩坑的点：</p><ul><li>Z 字形只是一个<strong>中间的写法</strong>，最终输出是「每一行拼起来」，不是按路径顺序</li><li><code>numRows = 1</code> 的时候，其实没有 Z 字形，结果就是原字符串</li><li>如果 <code>numRows &gt;= s.length</code>，每个字符一行，也等价于原字符串</li></ul><p>用样例感受一下题意：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>s = &quot;PAYPALISHIRING&quot;, numRows = 3</span></span>
<span class="line"><span></span></span>
<span class="line"><span>按 Z 字形写：</span></span>
<span class="line"><span>P   A   H   N</span></span>
<span class="line"><span>A P L S I I G</span></span>
<span class="line"><span>Y   I   R</span></span>
<span class="line"><span></span></span>
<span class="line"><span>按行读：PAHNAPLSIIGYIR</span></span></code></pre></div><p>如果是 <code>numRows = 4</code>：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>P     I     N</span></span>
<span class="line"><span>A   L S   I G</span></span>
<span class="line"><span>Y A   H R</span></span>
<span class="line"><span>P     I</span></span>
<span class="line"><span></span></span>
<span class="line"><span>结果：PINALSIGYAHRPI</span></span></code></pre></div><hr><h2 id="第一个下意识想法-直接「画矩阵」" tabindex="-1">第一个下意识想法：直接「画矩阵」 <a class="header-anchor" href="#第一个下意识想法-直接「画矩阵」" aria-label="Permalink to &quot;第一个下意识想法：直接「画矩阵」&quot;">​</a></h2><p>一般人第一次看到都会想：我要不要开一个二维数组，把字符一个个「走路径」填进去，最后按行读出来？</p><p>伪代码大概是：</p><ol><li>估算出矩阵需要多少列</li><li>开一个 <code>numRows x numCols</code> 的二维数组，先用空字符填满</li><li>从左上角开始，模拟「往下再往上」的走法，把 <code>s</code> 的字符按顺序放进去</li><li>最后按行把非空字符拼起来</li></ol><p>这确实能做出来，但有几个问题：</p><ul><li>你得先算「要多少列」——这本身就不太直观</li><li>矩阵里会有很多空格，空间利用率很低</li><li>实现会有不少边界判断，代码又长又不好读</li></ul><p>整体上，这个思路更多是在「照着图画」，而不是抓住本质结构。</p><hr><h2 id="换个视角-我真的需要矩阵吗" tabindex="-1">换个视角：我真的需要矩阵吗？ <a class="header-anchor" href="#换个视角-我真的需要矩阵吗" aria-label="Permalink to &quot;换个视角：我真的需要矩阵吗？&quot;">​</a></h2><p>仔细看题目，其实真正需要的是：</p><blockquote><p>每一行最终长成什么样，然后把所有行拼起来。</p></blockquote><p>中间是不是矩阵不重要，只要我能知道「某个字符属于哪一行」就够了。</p><p>这就引出了一个更自然的想法：</p><ul><li>我维护 <code>numRows</code> 个字符串（或者数组），分别对应「第 0 行、第 1 行...」</li><li>遍历原字符串 <code>s</code>，顺着 Z 字形的路径走</li><li>每拿到一个字符，就直接丢到当前行对应的那一条字符串里</li><li>最后把所有行拼接起来</li></ul><p>你可以把它想象成「按照 Z 字形顺序，往多个桶里扔字符」：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>行0: P   A   H   N   -&gt;  &quot;PAHN&quot;</span></span>
<span class="line"><span>行1: A P L S I I G   -&gt;  &quot;APLSIIG&quot;</span></span>
<span class="line"><span>行2: Y   I   R       -&gt;  &quot;YIR&quot;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>最后: &quot;PAHN&quot; + &quot;APLSIIG&quot; + &quot;YIR&quot;</span></span></code></pre></div><p>那问题就变成了：</p><blockquote><p>遍历字符串的时候，如何知道「当前应该往第几行写」，以及「什么时候往下走 / 往上走」？</p></blockquote><hr><h2 id="把「走-z-字形」抽象成一个状态机" tabindex="-1">把「走 Z 字形」抽象成一个状态机 <a class="header-anchor" href="#把「走-z-字形」抽象成一个状态机" aria-label="Permalink to &quot;把「走 Z 字形」抽象成一个状态机&quot;">​</a></h2><p>我们来直接模拟那条「Z 字形路径」：</p><ul><li>一开始在第 0 行，方向是「往下」</li><li>每读取一个字符： <ul><li>先把它追加到当前行</li><li>再根据当前方向，<code>curRow++</code> 或 <code>curRow--</code></li><li>如果走到第 0 行或最后一行，就反转方向</li></ul></li></ul><p>伪代码的状态大概是：</p><ul><li><code>curRow</code>：当前在哪一行</li><li><code>goingDown</code>：当前是不是在往下走（到底后会往上走）</li><li><code>rows[]</code>：每一行已经累积的字符串</li></ul><p>如果你手动模拟 <code>s = &quot;PAYPALISHIRING&quot;, numRows = 3</code>，状态会像这样变化：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>初始: curRow = 0, goingDown = false</span></span>
<span class="line"><span></span></span>
<span class="line"><span>P: 行0 &lt;- &#39;P&#39;   -&gt; rows[0] = &quot;P&quot;</span></span>
<span class="line"><span>   现在在第0行，掉头往下: goingDown = true, curRow = 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>A: 行1 &lt;- &#39;A&#39;   -&gt; rows[1] = &quot;A&quot;</span></span>
<span class="line"><span>   往下: curRow = 2</span></span>
<span class="line"><span></span></span>
<span class="line"><span>Y: 行2 &lt;- &#39;Y&#39;   -&gt; rows[2] = &quot;Y&quot;</span></span>
<span class="line"><span>   到底了，掉头往上: goingDown = false, curRow = 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>P: 行1 &lt;- &#39;P&#39;   -&gt; rows[1] = &quot;AP&quot;</span></span>
<span class="line"><span>   往上: curRow = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>A: 行0 &lt;- &#39;A&#39;   -&gt; rows[0] = &quot;PA&quot;</span></span>
<span class="line"><span>   到顶了，掉头往下...</span></span>
<span class="line"><span>...</span></span></code></pre></div><p>这样一来，我们完全不用管列数，甚至不用真的画出矩阵，只要维护「当前行」和「方向」即可。</p><hr><h2 id="代码实现-每一行都有-存在理由" tabindex="-1">代码实现（每一行都有“存在理由”） <a class="header-anchor" href="#代码实现-每一行都有-存在理由" aria-label="Permalink to &quot;代码实现（每一行都有“存在理由”）&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> convert</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">s</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">numRows</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 特殊情况：只有一行时，没有 Z 字形，直接返回原字符串</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 或者行数 &gt;= 字符长度时，每个字符一行，读出来也等于原串</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (numRows </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numRows </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&gt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 用数组来存每一行的字符串，后面 join 即可</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 为什么不用一个巨大的二维数组？</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 因为我们根本不关心列，只关心“这一行的字符顺序”</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> rows</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Array</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(numRows).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fill</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curRow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 当前在哪一行</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> goingDown </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> false</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> // 当前是否在“往下走”</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 遍历原字符串中的每个字符</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> ch</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> of</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> s) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 把字符拼到当前行后面</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        rows[curRow] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> ch</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 如果走到顶部或底部，就反转方向</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (curRow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> ||</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> curRow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> numRows </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            goingDown </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">goingDown</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 根据方向决定下一步走向哪一行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        curRow </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> goingDown </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">?</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> :</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 最后按行拼接</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> rows.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">join</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>可以自己拿前面的例子手动跑一下，对比一下 <code>rows</code> 在每一步的变化，会更有感觉。</p><hr><h2 id="进阶视角-周期-按公式算下标-可选思路" tabindex="-1">进阶视角：周期 &amp; 按公式算下标（可选思路） <a class="header-anchor" href="#进阶视角-周期-按公式算下标-可选思路" aria-label="Permalink to &quot;进阶视角：周期 &amp; 按公式算下标（可选思路）&quot;">​</a></h2><p>如果你对规律再敏感一点，会发现 Z 字形其实是有「周期」的。</p><p>假设 <code>numRows = r</code>，那么一整个「下去 + 上来」的周期长度是：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>cycleLen = 2 * r - 2</span></span></code></pre></div><p>比如 <code>r = 3</code> 时：</p><div class="language-text vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">text</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span>P   A   H   N</span></span>
<span class="line"><span>A P L S I I G</span></span>
<span class="line"><span>Y   I   R</span></span>
<span class="line"><span></span></span>
<span class="line"><span>cycleLen = 4</span></span>
<span class="line"><span>下标:     0 1 2 3 4 5 6 7 8 9 ...</span></span>
<span class="line"><span>行0:      0       4       8   ...</span></span>
<span class="line"><span>行1:        1   3   5   7   ...</span></span>
<span class="line"><span>行2:          2       6       ...</span></span></code></pre></div><p>你会发现：</p><ul><li>第一行和最后一行：每次跳 <code>cycleLen</code></li><li>中间的行：在一个周期内会出现两次，对应的下标可以按公式算出来</li></ul><p>基于这个规律，我们可以不用模拟走路径，而是按行、按周期直接算出每个位置的下标。这会让代码稍微「数学一点」，但本质复杂度还是 O(n)。</p><p>在面试场景下，一般用「模拟走路径 + rows 数组」就足够了，思路更直观、实现也更安全。</p><hr><h2 id="这题到底在考什么" tabindex="-1">这题到底在考什么？ <a class="header-anchor" href="#这题到底在考什么" aria-label="Permalink to &quot;这题到底在考什么？&quot;">​</a></h2><p>表面上看，这题在考「字符串重排」或者「模拟 Z 字形」，但更底层的考点是：</p><ol><li><p><strong>能不能从“画图”抽象到“状态机”</strong><br> 一开始你可能会画出一个二维矩阵，仔细想想就会发现其实只需要知道「当前在哪一行」「当前方向是什么」，这就是一个很小的状态机。</p></li><li><p><strong>对「模式」的敏感度</strong><br> 看到 Z 字形，其实就是一个「下去 + 上来」的周期运动。抽象出来之后，写代码就只是实现这个模式。</p></li><li><p><strong>边界条件的处理意识</strong></p><ul><li><code>numRows = 1</code> 或 <code>numRows &gt;= s.length</code> 这些 corner case 如果不先 return，很容易在循环里出 bug</li><li>顶部 / 底部反转方向，是这道题的关键边界</li></ul></li></ol><p>下次遇到类似题目，只要看到：</p><ul><li>把元素「绕着某条路径」放到不同的桶里，最后再按桶合并</li><li>路径有明显的「往下 / 往上」「往左 / 往右」周期性模式</li></ul><p>就可以优先考虑：</p><ul><li>直接维护「若干行（桶）」而不是完整矩阵</li><li>用一个 <code>curIndex + direction</code> 的小状态机来模拟路径</li></ul><p>而不是上来就去构造一个二维数组，把图画得很「原始」。这种从「画图」到「抽象状态」的过程，其实就是很多模拟题背后的共性。</p>`,61),e=[l];function t(h,k,o,c,r,d){return i(),a("div",null,e)}const u=s(p,[["render",t]]);export{E as __pageData,u as default};
