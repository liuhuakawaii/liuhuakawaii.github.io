(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{414:function(n,t,e){n.exports=e.p+"assets/img/121102.1e54c76a.png"},415:function(n,t,e){n.exports=e.p+"assets/img/121101.a781799a.png"},612:function(n,t,e){"use strict";e.r(t);var i=e(2),r=Object(i.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"数据结构-链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数据结构-链表"}},[n._v("#")]),n._v(" 数据结构---链表")]),n._v(" "),t("h3",{attrs:{id:"链表与数组的对比"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表与数组的对比"}},[n._v("#")]),n._v(" 链表与数组的对比")]),n._v(" "),t("ol",[t("li",[n._v("数组")])]),n._v(" "),t("ul",[t("li",[n._v("最常用的存储多个元素的数据结构")]),n._v(" "),t("li",[n._v("缺点：\n"),t("ol",[t("li",[n._v("数组的创建通常需要申请"),t("strong",[n._v("一段连续的内存空间")]),n._v("（一整块内存），并且大小是固定的，所以当当前数组"),t("strong",[n._v("不能满足容量需求")]),n._v("时，需要"),t("strong",[n._v("扩容")]),n._v("，（一般情况下是申请一个更大的数组，比如两倍，然后将原数组中的元素复制过去）")]),n._v(" "),t("li",[n._v("而且在数组开头或者中间位置插入数据的成本很高，需要进行大量元素的位移")]),n._v(" "),t("li",[n._v("尽管我们已经学过的js的Array类方法可以帮我们做这些事，但背后的原理依然是这样")])])])]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[n._v("链表\n"),t("ul",[t("li",[n._v("要存储多个元素，另外一个选择就是链表")]),n._v(" "),t("li",[n._v("但不同于数组，链表中的元素在内存中"),t("strong",[n._v("不必是连续的空间")])]),n._v(" "),t("li",[n._v("链表的每一个元素由一个存储"),t("strong",[n._v("元素本身的节点")]),n._v("和一个"),t("strong",[n._v("指向下一个元素的引用")]),n._v("（指针）组成")]),n._v(" "),t("li",[n._v("优点：\n"),t("ol",[t("li",[n._v("内存空间不是必须连续的，可以充分利用计算机的内存，实现灵活的"),t("strong",[n._v("内存动态管理")])]),n._v(" "),t("li",[n._v("链表不必再创建时就"),t("strong",[n._v("确定大小")]),n._v("，并且大小可以"),t("strong",[n._v("无限的延伸")]),n._v("下去")]),n._v(" "),t("li",[n._v("链表在"),t("strong",[n._v("插入和删除")]),n._v("数据时，"),t("strong",[n._v("时间复杂度")]),n._v("可以达到O（1），相对数组效率高很多，只需要改变指针指向")])])]),n._v(" "),t("li",[n._v("缺点：\n"),t("ol",[t("li",[n._v("链表访问任何一个位置的元素时，都需要"),t("strong",[n._v("从头开始访问")]),n._v("。（无法跳过第一个元素访问任何一个元素）")]),n._v(" "),t("li",[n._v("无法通过下标直接访问，需要一个个从头访问")])])])])])]),n._v(" "),t("h3",{attrs:{id:"什么是链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是链表"}},[n._v("#")]),n._v(" 什么是链表")]),n._v(" "),t("ul",[t("li",[t("p",[n._v("链表类似于火车：有一个火车头，火车头会链接一个节点，节点上有乘客（类似于数据），并且这个节点会链接下一个节点"),t("br"),n._v(" "),t("img",{attrs:{src:e(414),alt:""}}),t("br"),n._v(" "),t("img",{attrs:{src:e(415),alt:""}})])]),n._v(" "),t("li",[t("p",[n._v("单向链表的封装\n```js"),t("br"),n._v("\n//封装链表类\nfunction LinkedList(){\n//  内部的类：节点类"),t("br"),n._v("\nfunction Node(data,next = null){\nthis.data = data\n}\n//属性"),t("br"),n._v("\nthis.head = null //头指针\nthis.length = 0")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("        //1.追加方法    \n        LinkedList.prototype.append = function(data){\n          //1.创建新节点\n          let newNode = new Node(data)\n          //2.判断是否添加的是第一个节点\n          if(this.length === 0){//2.1是第一个节点\n            this.head = newNode\n          }else{//2.2不是第一个节点  \n            let current = this.head\n            while(current.next){\n              //找到最后一个节点\n              current = current.next \n            }\n            //最后节点的next指向新的节点\n            current.next = newNode\n          }\n          //3.length+1\n          this.length += 1\n        }   \n\n        //2.toString方法\n        LinkedList.prototype.toString = function(){\n          //1.定义变量\n          let current = this.head\n          let listString = ''\n          //2.循环获取一个个的节点\n          while(current){\n            listString += current.data + ' '\n            current = current.next\n          }\n          return listString\n        }   \n\n        //3.insert方法的实现    \n        LinkedList.prototype.insert = function(position,data){\n          //1.对position进行越界判断\n          if(position < 0 || position > this.length) return false\n          //2.创建节点           \n          let newNode = new Node(data)   \n          let current = this.head\n          if(position == 0){\n            //如果加到头结点位置  \n            newNode.next = this.head\n            this.head = newNode\n          }else{//其他位置position -1 的next指向自己。自己的next指向原来的position\n            let index = 0\n            let previous = null\n            while(index++ < position){\n              previous = current\n              current = current.next\n            }\n            newNode.next = current\n            previous.next = newNode\n          }\n          this.length += 1\n          return true\n        }     \n\n        //4. get方法    \n        LinkedList.prototype.get = function(position){\n          //1.对position进行越界判断\n          if(position < 0 || position >= this.length) return null  \n          //2. 获取对应的data    \n          let current = this.head\n          let index = 0\n          while(index++ < position){\n              current = current.next\n          }\n          return current.data\n        }   \n\n        //5.  indexOf方法\n        LinkedList.prototype.indexOf = function(data){\n          let current = this.head\n          let index = 0\n          while(current){\n            if(data == current.data) return index\n            current = current.next\n            index++\n          }\n          return -1\n        } \n\n        //6. update(position,ele)方法   update(2,aaa)\n        LinkedList.prototype.update = function(position,data){\n            //1.对position进行越界判断\n          if(position < 0 || position >= this.length) return false \n          let current = this.head\n          let index = 0\n          while(index++ < position){//还没有找到position位置\n            current = current.next\n          }\n          current.data = data\n          return true\n        }     \n\n        //7.removeAt方法  \n        LinkedList.prototype.removeAt = function(position){\n            //1.对position进行越界判断\n          if(position < 0 || position >= this.length) return false \n          let current = this.head\n          let index = 0\n          let previous = null\n          if(position == 0){\n            this.head = current.next\n          }else{\n            while(index++ < position){//还没有找到position位置\n              previous =current\n              current = current.next\n            }\n            previous.next = current.next\n          }\n          this.length--\n          return true\n        } \n        \n        //8. remove方法       \n        LinkedList.prototype.remove = function(data){\n          let position = this.indexOf(data)\n          return this.removeAt(position)\n        } \n        //9.isEmpty()\n        LinkedList.prototype.isEmpty = function(){\n          return this.length === 0\n        }  \n        //10.size()\n        LinkedList.prototype.size = function(){\n          return this.length\n        } \n      }\n    let list = new LinkedList()   \n```")])])])])])])}),[],!1,null,null,null);t.default=r.exports}}]);