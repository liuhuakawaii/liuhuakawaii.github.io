(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{597:function(l,v,_){"use strict";_.r(v);var t=_(2),N=Object(t.a)({},(function(){var l=this,v=l._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[v("h2",{attrs:{id:"时间复杂度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#时间复杂度"}},[l._v("#")]),l._v(" 时间复杂度")]),l._v(" "),v("ol",[v("li",[v("p",[l._v("时间复杂度")]),l._v(" "),v("ul",[v("li",[l._v("一个操作如果和样本的数据量没有关系，每次都是固定时间内完成的操作，叫做"),v("strong",[l._v("常数操作")]),l._v(" "),v("ul",[v("li",[l._v("例如 "),v("code",[l._v("arr[i]")]),l._v("寻址，只是计算了偏移量，"),v("code",[l._v("+-*/")]),l._v("和位运算都是常数操作，遍历，链表查找就不是常数操作")])])]),l._v(" "),v("li",[l._v("在表达式中，只要高阶项，不要低阶项，也不要高阶项的系数，剩下的部分如果是f(N),那么时间复杂度就是O(f(N))\n"),v("ul",[v("li",[l._v("例如冒泡排序，第一次遍历了N次，然后比较数据N次，交换数据1次，第二遍遍历了N-1次....循环往复，我们可以得知遍历（N+N-1+N-2+...+1）=(N(1+N)/2),同理比较数据也是(N(1+N)/2)，交换数据是N次，总共是（aN^2+bN+c）,忽略之后就是O(N^2)")])])])])]),l._v(" "),v("li",[v("p",[l._v("利用master公式估算递归行为的时间复杂度")]),l._v(" "),v("ul",[v("li",[v("code",[l._v("T(N) = a*T(N/b) + O(N^d)")])]),l._v(" "),v("li",[l._v("其中T(N)表示母问题的规模，a*T(N/b)表示a个"),v("strong",[l._v("被等分")]),l._v("的子问题,O(N^d)表示剩余操作的空间复杂度")]),l._v(" "),v("li",[l._v("时间复杂度：\n"),v("ul",[v("li",[l._v("log(b,a) < d   --\x3e  O(N^d)")]),l._v(" "),v("li",[l._v("log(b,a) > d   --\x3e  O(N^log(b,a))")]),l._v(" "),v("li",[l._v("log(b,a) = d   --\x3e  O(logN * N^d)")])])])])])])])}),[],!1,null,null,null);v.default=N.exports}}]);