import{_ as s,c as i,o as a,a7 as n}from"./chunks/framework.DLSH1pMh.js";const c=JSON.parse('{"title":"1-两数之和","description":"","frontmatter":{"title":"1-两数之和","date":"2026-02-05T00:00:00.000Z","categories":["leetcode"],"tags":["数据结构","JavaScript","前端进阶","算法"]},"headers":[],"relativePath":"blogs/leetcode/1-100/1-两数之和.md","filePath":"blogs/leetcode/1-100/1-两数之和.md"}'),t={name:"blogs/leetcode/1-100/1-两数之和.md"},h=n(`<h1 id="两数之和" tabindex="-1"><a href="https://leetcode.cn/problems/two-sum/" target="_blank" rel="noreferrer">两数之和</a> <a class="header-anchor" href="#两数之和" aria-label="Permalink to &quot;[两数之和](https://leetcode.cn/problems/two-sum/)&quot;">​</a></h1><p>这道题算是 LeetCode 的入门题了，但仔细想想，其实挺有意思的。题目要求很简单：给你一个整数数组和一个目标值，找出数组中两个数的和等于目标值，返回这两个数的下标。</p><p>注意几个关键点：返回的是<strong>下标</strong>而不是值，同一个元素不能使用两次（但值可以相同，比如 <code>[3, 3]</code> 在 target=6 时可以用两个3），题目保证有且仅有一组解。</p><h2 id="最直观的想法" tabindex="-1">最直观的想法 <a class="header-anchor" href="#最直观的想法" aria-label="Permalink to &quot;最直观的想法&quot;">​</a></h2><p>第一次看到这题，我的第一反应就是：把所有可能的两个数组合都试一遍不就完了？</p><p>两层循环，外层遍历第一个数，内层遍历第二个数，检查它们的和是否等于 target。这是最&quot;暴力&quot;的方法，但也是最直观的：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> twoSum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (nums[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[j] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">                return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [i, j]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">            }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>时间复杂度 O(n²)，空间复杂度 O(1)。对于小数组来说完全没问题，但数组大了就会慢。</p><h2 id="问题在哪" tabindex="-1">问题在哪？ <a class="header-anchor" href="#问题在哪" aria-label="Permalink to &quot;问题在哪？&quot;">​</a></h2><p>仔细想想，这个方法其实做了很多重复工作。</p><p>当我们检查 <code>nums[i] + nums[j] === target</code> 时，我们已经知道了 <code>nums[i]</code> 和 <code>target</code>，所以 <code>nums[j]</code> 应该等于 <code>target - nums[i]</code>。但我们还是用循环去找这个值，这就是重复工作。</p><p>而且，如果我们需要快速查找&quot;某个值是否在数组中&quot;，用循环是 O(n)，但用哈希表（Map/Set）可以做到 O(1)。</p><h2 id="换个思路" tabindex="-1">换个思路 <a class="header-anchor" href="#换个思路" aria-label="Permalink to &quot;换个思路&quot;">​</a></h2><p>既然我们需要找的是 <code>target - nums[i]</code>，那能不能在遍历的时候，把已经见过的数字存起来，这样下次需要查找的时候就能直接找到了？</p><p>这就是哈希表的思路。我们可以用一个 Map 记录&quot;值 -&gt; 索引&quot;的映射，遍历数组时：</p><ul><li>计算 <code>remain = target - nums[i]</code></li><li>检查 <code>remain</code> 是否在 Map 中</li><li>如果在，说明找到了，返回 <code>[map.get(remain), i]</code></li><li>如果不在，把 <code>nums[i]</code> 存入 Map，继续遍历</li></ul><p>关键点：<strong>先查找再存入</strong>。这样可以避免&quot;同一个元素使用两次&quot;的问题。比如 <code>nums = [3, 3]</code>, <code>target = 6</code>，如果先存入再查找，遍历到第二个 3 时会错误地返回 <code>[0, 0]</code>。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">var</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> twoSum</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">nums</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">target</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> map</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Map</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums.</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> remain</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> target </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> nums[i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 先查找，避免自匹配</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">has</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(remain)) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> [map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">get</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(remain), i]</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        </span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">        // 再存入，供后续查找使用</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        map.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">set</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(nums[i], i)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    </span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> []</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>这样时间复杂度降到了 O(n)，空间复杂度 O(n)。用空间换时间，这是查找问题的经典优化思路。</p><h2 id="为什么这样能工作" tabindex="-1">为什么这样能工作？ <a class="header-anchor" href="#为什么这样能工作" aria-label="Permalink to &quot;为什么这样能工作？&quot;">​</a></h2><p>当我们遍历到 <code>nums[i]</code> 时，我们检查的是&quot;之前是否见过 <code>target - nums[i]</code>&quot;。如果见过，说明这两个数一个在前面（索引在 Map 中），一个在当前位置（索引是 i），直接返回即可。</p><p>如果没见过，继续遍历，把当前数存入 Map。这样后续遍历时，如果遇到能配对的数，就能直接找到了。</p><h2 id="这道题在考什么" tabindex="-1">这道题在考什么？ <a class="header-anchor" href="#这道题在考什么" aria-label="Permalink to &quot;这道题在考什么？&quot;">​</a></h2><p>这道题的核心是<strong>哈希表的应用</strong>。当我们需要快速查找&quot;某个值是否出现过&quot;时，哈希表是首选。用 O(n) 的空间换 O(n) 的时间，避免了嵌套循环。</p><p>下次遇到类似题目，看到&quot;查找&quot;、&quot;是否存在&quot;这些关键词，就应该想到哈希表。比如三数之和、四数之和这些题，虽然解法不同，但思路都是类似的。</p><p><strong>记忆要点：</strong></p><ul><li>查找问题 → 哈希表</li><li>一次遍历 → 边遍历边查找</li><li>先查找再存入 → 避免自匹配</li></ul>`,27),l=[h];function p(k,e,r,E,d,g){return a(),i("div",null,l)}const y=s(t,[["render",p]]);export{c as __pageData,y as default};
