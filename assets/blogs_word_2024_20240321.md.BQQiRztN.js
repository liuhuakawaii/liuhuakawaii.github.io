import{_ as s,c as i,o as a,a5 as n}from"./chunks/framework.Bx-mEslM.js";const y=JSON.parse('{"title":"解决iframe中的mousemove在parent window中延续的问题","description":"","frontmatter":{"title":"解决iframe中的mousemove在parent window中延续的问题","date":"2024-3-21","categories":["前端进阶","工作随记"]},"headers":[],"relativePath":"blogs/word/2024/20240321.md","filePath":"blogs/word/2024/20240321.md"}'),e={name:"blogs/word/2024/20240321.md"},l=n(`<h1 id="解决iframe中的mousemove在parent-window中延续的问题-🖱️" tabindex="-1">解决iframe中的mousemove在parent window中延续的问题 🖱️ <a class="header-anchor" href="#解决iframe中的mousemove在parent-window中延续的问题-🖱️" aria-label="Permalink to &quot;解决iframe中的mousemove在parent window中延续的问题 🖱️&quot;">​</a></h1><h2 id="背景描述-📝" tabindex="-1">背景描述 📝 <a class="header-anchor" href="#背景描述-📝" aria-label="Permalink to &quot;背景描述 📝&quot;">​</a></h2><p>在开发过程中遇到一个有趣的问题：我们在iframe中实现了一个3D模型预览功能，通过mousedown + mousemove来控制模型旋转。但是当用户鼠标移出iframe范围时，mousemove事件就会失效，严重影响了用户体验。</p><h2 id="常见解决方案及其局限性-🤔" tabindex="-1">常见解决方案及其局限性 🤔 <a class="header-anchor" href="#常见解决方案及其局限性-🤔" aria-label="Permalink to &quot;常见解决方案及其局限性 🤔&quot;">​</a></h2><p>最常见的解决方案是通过iframe和parent window之间的通信来实现：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// iframe内部</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mousedown&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.parent.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">postMessage</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">({type: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;mousedown&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;*&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// parent window</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;message&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.data.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">===</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &#39;mousedown&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mousemove&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mouseMoveHandler);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">        window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mouseup&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, mouseUpHandler);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span></code></pre></div><p>这种方案存在以下问题：</p><ul><li>需要处理复杂的事件传递逻辑</li><li>涉及坐标系转换</li><li>需要同步管理多个事件监听器</li><li>代码维护成本高</li></ul><h2 id="意外发现的解决方案-💡" tabindex="-1">意外发现的解决方案 💡 <a class="header-anchor" href="#意外发现的解决方案-💡" aria-label="Permalink to &quot;意外发现的解决方案 💡&quot;">​</a></h2><p>在实验过程中，我发现了一个有趣的现象。这里通过两个demo来说明：</p><h3 id="demo-1-传统的事件监听方式" tabindex="-1">Demo 1: 传统的事件监听方式 <a class="header-anchor" href="#demo-1-传统的事件监听方式" aria-label="Permalink to &quot;Demo 1: 传统的事件监听方式&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 直接在window上绑定事件</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mousemove&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handleIframeMouseMove);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;mouseup&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, handleIframeMouseUp);</span></span></code></pre></div><p>这种方式下，当鼠标移出iframe后，mousemove事件就会停止监听。</p><h3 id="demo-2-动态绑定事件处理器" tabindex="-1">Demo 2: 动态绑定事件处理器 <a class="header-anchor" href="#demo-2-动态绑定事件处理器" aria-label="Permalink to &quot;Demo 2: 动态绑定事件处理器&quot;">​</a></h3><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleIframeMouseDown</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.onmousemove </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handleIframeMouseMove;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.onmouseup </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> handleIframeMouseUp;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleIframeMouseMove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">e</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`Mouse position - X: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">clientX</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}, Y: \${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">e</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">clientY</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> handleIframeMouseUp</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.onmousemove </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    window.onmouseup </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> null</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>神奇的是，这种方式可以在鼠标移出iframe后继续捕获mousemove事件！</p><h2 id="技术原理解释-📚" tabindex="-1">技术原理解释 📚 <a class="header-anchor" href="#技术原理解释-📚" aria-label="Permalink to &quot;技术原理解释 📚&quot;">​</a></h2><p>这个现象的关键在于事件绑定的时机和方式：</p><ol><li><code>addEventListener</code>方式是声明式的事件绑定，作用域局限于当前window环境</li><li><code>onmousemove</code>赋值方式是在mousedown触发后动态绑定的，此时浏览器已建立了事件追踪上下文</li></ol><h2 id="最佳实践建议-✨" tabindex="-1">最佳实践建议 ✨ <a class="header-anchor" href="#最佳实践建议-✨" aria-label="Permalink to &quot;最佳实践建议 ✨&quot;">​</a></h2><ol><li>在需要跨iframe追踪鼠标事件时，优先使用动态绑定方式</li><li>注意及时清理事件监听器，避免内存泄漏</li><li>考虑添加错误处理和边界情况检查</li></ol><h2 id="注意事项-⚠️" tabindex="-1">注意事项 ⚠️ <a class="header-anchor" href="#注意事项-⚠️" aria-label="Permalink to &quot;注意事项 ⚠️&quot;">​</a></h2><ul><li>确保iframe和父页面同源，否则可能存在跨域问题</li><li>在移动端需要额外处理touch事件</li><li>注意性能优化，可以使用防抖或节流处理mousemove事件</li></ul><p>希望这个发现能帮助遇到类似问题的开发者！如果你有更好的解决方案或者发现了其他有趣的现象，欢迎讨论交流。🤝</p>`,24),h=[l];function t(p,k,E,d,r,o){return a(),i("div",null,h)}const c=s(e,[["render",t]]);export{y as __pageData,c as default};
