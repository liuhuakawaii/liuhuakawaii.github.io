import{_ as i,c as o,o as l,a3 as e}from"./chunks/framework.DpzXWsSh.js";const u=JSON.parse('{"title":"前端登录","description":"","frontmatter":{"title":"前端登录","date":"2023-8-25","tags":null,"categories":["javascript","踩坑","面试"]},"headers":[],"relativePath":"blogs/word/2023/0825.md","filePath":"blogs/word/2023/0825.md"}'),a={name:"blogs/word/2023/0825.md"},t=e('<ul><li>摘自 <a href="https://zhuanlan.zhihu.com/p/153509344" target="_blank" rel="noreferrer"></a></li></ul><h2 id="前端登录" tabindex="-1">前端登录 <a class="header-anchor" href="#前端登录" aria-label="Permalink to &quot;前端登录&quot;">​</a></h2><h2 id="cookie-session-登录" tabindex="-1">Cookie + Session 登录 <a class="header-anchor" href="#cookie-session-登录" aria-label="Permalink to &quot;Cookie + Session 登录&quot;">​</a></h2><ol><li>产生背景： <ul><li>HTTP 是一种无状态的协议，客户端每次发送请求时，首先要和服务器端建立一个连接，在请求完成后又会断开这个连接。这种方式可以节省传输时占用的连接资源，但同时也存在一个问题：每次请求都是独立的，服务器端无法判断本次请求和上一次请求是否来自同一个用户，进而也就无法判断用户的登录状态。</li><li>为了解决 HTTP 无状态的问题，Lou Montulli 在 1994 年的时候，推出了 Cookie。</li><li>Cookie 是服务器端发送给客户端的一段特殊信息，这些信息以文本的方式存放在客户端，客户端每次向服务器端发送请求时都会带上这些特殊信息。</li><li>如果需要对信息进行验证，还需要通过 Session。</li><li>客户端请求服务端，服务端会为这次请求开辟一块内存空间，这个便是 Session 对象。</li></ul></li><li>流程 <ol><li>用户访问 a.com/pageA，并输入密码登录。</li><li>服务器验证密码无误后，会创建 SessionId，并将它保存起来。</li><li>服务器端响应这个 HTTP 请求，并通过 Set-Cookie 头信息，将 SessionId 写入 Cookie 中，把Cookie返给客户端</li><li>客户端后续就可以通过Cookie（未过期前）直接进行身份验证</li></ol></li><li>Cookie + Session 存在的问题 <ol><li>由于服务器端需要对接大量的客户端，也就需要存放大量的 SessionId，这样会导致服务器压力过大。</li><li>如果服务器端是一个集群，为了同步登录态，需要将 SessionId 同步到每一台机器上，无形中增加了服务器端维护成本。</li><li>由于 SessionId 存放在 Cookie 中，所以无法避免 CSRF 攻击。</li></ol></li></ol><h2 id="token-登录" tabindex="-1">Token 登录 <a class="header-anchor" href="#token-登录" aria-label="Permalink to &quot;Token 登录&quot;">​</a></h2><ol><li><p>Token 是服务端生成的一串字符串，以作为客户端请求的一个令牌。当第一次登录后，服务器会生成一个 Token 并返回给客户端，客户端后续访问时，只需带上这个 Token 即可完成身份认证。</p></li><li><p>流程</p><ol><li>用户输入账号密码，并点击登录。</li><li>服务器端验证账号密码无误，创建 Token。</li><li>服务器端将 Token 返回给客户端，由<em><strong>客户端自由保存</strong></em>。</li><li>后续页面访问的时候 带上第一次登录时获取的 Token。服务器端验证 Token ，有效则身份验证成功。</li></ol></li><li><p>特点</p><ol><li>服务器端不需要存放 Token，所以不会对服务器端造成压力，即使是服务器集群，也不需要增加维护成本。</li><li>Token 可以存放在前端任何地方，可以不用保存在 Cookie 中，提升了页面的安全性。</li><li>Token 下发之后，只要在生效时间之内，就一直有效，如果服务器端想收回此 Token 的权限，并不容易。</li></ol></li><li><p>Token 的生成方式</p><ol><li>最常见的 Token 生成方式是使用 JWT（Json Web Token）</li><li>其实 Token 并不是一串杂乱无章的字符串，而是通过多种算法拼接组合而成的字符串</li><li>JWT 算法主要分为 3 个部分：header（头信息），playload（消息体），signature（签名）。</li></ol></li></ol><h2 id="sso-单点登录" tabindex="-1">SSO 单点登录 <a class="header-anchor" href="#sso-单点登录" aria-label="Permalink to &quot;SSO 单点登录&quot;">​</a></h2><ol><li><p>流程</p><ol><li>用户首次访问时，需要在认证中心登录：</li><li>用户访问网站 a.com 下的 pageA 页面。</li><li>由于没有登录，则会重定向到认证中心，并带上回调地址 www.sso.com?return_uri=a.com/pageA，以便登录后直接进入对应页面。</li><li>用户在认证中心输入账号密码，提交登录。</li><li>认证中心验证账号密码有效，然后重定向 a.com?ticket=123 带上授权码 ticket，并将认证中心 sso.com 的登录态写入 Cookie。</li><li>在 a.com 服务器中，拿着 ticket 向认证中心确认，授权码 ticket 真实有效。</li><li>验证成功后，服务器将登录信息写入 Cookie（此时客户端有 2 个 Cookie 分别存有 a.com 和 sso.com 的登录态）。</li><li>认证中心登录完成之后，继续访问 a.com 下的其他页面：这个时候，由于 a.com 存在已登录的 Cookie 信息，所以服务器端直接认证成功。</li><li>如果认证中心登录完成之后，访问 b.com 下的页面：这个时候，由于认证中心存在之前登录过的 Cookie，所以也不用再次输入账号密码，直接返回第 4 步，下发 ticket 给 b.com 即可。</li></ol></li><li><p>SSO 单点登录退出</p><ul><li><p>在同一套认证中心的管理下，多个产品可以共享登录态。现在我们需要考虑退出了，即：在一个产品中退出了登录，怎么让其他的产品也都退出登录？</p></li><li><p>原理其实不难，可以回过头来看第 5 步，每一个产品在向认证中心验证 ticket 时，其实可以顺带将自己的退出登录 api 发送到认证中心。</p></li><li><p>当某个产品 c.com 退出登录时：</p><ol><li>清空 c.com 中的登录态 Cookie。</li><li>请求认证中心 sso.com 中的退出 api。</li><li>认证中心遍历下发过 ticket 的所有产品，并调用对应的退出 api，完成退出。</li></ol></li></ul></li></ol><h2 id="oauth-第三方登录" tabindex="-1">OAuth 第三方登录 <a class="header-anchor" href="#oauth-第三方登录" aria-label="Permalink to &quot;OAuth 第三方登录&quot;">​</a></h2><ul><li>以微信开放平台的接入流程为例： <ol><li>首先，a.com 的运营者需要在微信开放平台注册账号，并向微信申请使用微信登录功能。</li><li>申请成功后，得到申请的 appid、appsecret。</li><li>用户在 a.com 上选择使用微信登录。</li><li>这时会跳转微信的 OAuth 授权登录，并带上 a.com 的回调地址。</li><li>用户输入微信账号和密码，登录成功后，需要选择具体的授权范围，如：授权用户的头像、昵称等。</li><li>授权之后，微信会根据拉起 a.com?code=123 ，这时带上了一个临时票据 code。</li><li>获取 code 之后， a.com 会拿着 code 、appid、appsecret，向微信服务器申请 token，验证成功后，微信会下发一个 token。</li><li>有了 token 之后， a.com 就可以凭借 token 拿到对应的微信用户头像，用户昵称等信息了。</li><li>a.com 提示用户登录成功，并将登录状态写入 Cooke，以作为后续访问的凭证。</li></ol></li></ul>',10),s=[t];function n(c,r,k,p,d,h){return l(),o("div",null,s)}const T=i(a,[["render",n]]);export{u as __pageData,T as default};
