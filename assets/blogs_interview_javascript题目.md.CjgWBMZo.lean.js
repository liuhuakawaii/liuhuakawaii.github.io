import{_ as k,D as p,c as t,l as s,a as i,I as n,w as h,a5 as l,o as e}from"./chunks/framework.BIhQMg0k.js";const T=JSON.parse('{"title":"面试宝典 - JavaScript题目","description":"","frontmatter":{"title":"面试宝典 - JavaScript题目","needVerify":true,"date":"2024-12-12T00:00:00.000Z","categories":["面试","javascript"]},"headers":[],"relativePath":"blogs/interview/javascript题目.md","filePath":"blogs/interview/javascript题目.md"}'),E={name:"blogs/interview/javascript题目.md"},r=l("",3),d=l("",7),g=l("",34),y=s("li",null,[i("当执行 "),s("code",null,"const o = { m:30 }"),i(" 时，相当于在堆内存开辟一块空间，存储"),s("code",null,"{ m:30 }"),i(",同时利用变量 "),s("code",null,"o"),i(" 记录该堆内存地址，"),s("code",null,"o"),i(" 存放在栈")],-1),F=s("code",null,"fn(o)",-1),o=s("code",null,"o",-1),c=s("code",null,"fn",-1),C=s("code",null,"obj",-1),A=l("",3),D=l("",2),u=s("strong",null,"进行页面的一系列交互操作",-1),B=s("strong",null,"用户互动",-1),b=s("strong",null,"竞态条件",-1),v=s("strong",null,"死锁",-1),m=s("strong",null,"资源竞争",-1),j=l("",399);function f(q,P,x,S,w,_){const a=p("font");return e(),t("div",null,[r,s("ul",null,[s("li",null,[s("strong",null,[i("上边效率更高，重用了 "),n(a,{color:"#ff0000"},{default:h(()=>[i("隐藏类（Hidden Class）")]),_:1})])])]),d,s("ul",null,[s("li",null,[s("strong",null,[i("上边效率更高，利用了数组的 "),n(a,{color:"#ff0000"},{default:h(()=>[i("快速模式")]),_:1})])])]),g,s("ul",null,[s("li",null,[i("解析： "),s("ul",null,[y,s("li",null,[i("当执行 "),F,i(" 时，会把 "),o,i(" 记录的地址值作为实参传递到方法 "),c,i(" 中，同时记录在 "),C,i(" 副本变量中（"),n(a,{color:"red"},{default:h(()=>[i("JS的传参都是值传递")]),_:1}),i("）")]),A])])]),D,s("p",null,[i("javascript 是浏览器的脚本语言，主要用途是"),n(a,{color:"red"},{default:h(()=>[u]),_:1}),i("以及"),n(a,{color:"red"},{default:h(()=>[B]),_:1}),i("，多线程编程通常会引发"),n(a,{color:"red"},{default:h(()=>[b]),_:1}),i("、"),n(a,{color:"red"},{default:h(()=>[v]),_:1}),i("和"),n(a,{color:"red"},{default:h(()=>[m]),_:1}),i("等问题。如果以多线程的方式进行浏览器操作，则可能出现不可预测的冲突。假设有两个线程同时操作同一个 DOM 元素，线程1 要求浏览器修改 DOM 内容，而线程2却要求删除 DOM，浏览器就疑惑，无法决定采用哪个线程的操作。所以 JavaScript 的单线程设计很好的简化了这类并发问题，避免了因多线程而引发的竞态条件、死锁和资源竞争等问题。当然，如果在开发中确切需要到异步场景，javascript 也有众多的异步队列来帮助我们实现，也就是我们熟知的事件循环，微任务队列，宏任务队列。如果真的需要开辟一个新线程处理逻辑，也可以通过 webworker 实现。")]),j])}const M=k(E,[["render",f]]);export{T as __pageData,M as default};
