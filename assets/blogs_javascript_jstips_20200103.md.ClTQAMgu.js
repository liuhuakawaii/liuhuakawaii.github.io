import{_ as s,c as i,o as a,a7 as n}from"./chunks/framework.DLSH1pMh.js";const c=JSON.parse('{"title":"JavaScript对象属性的遍历顺序详解","description":"","frontmatter":{"title":"JavaScript对象属性的遍历顺序详解","date":"2020-02-03T00:00:00.000Z","categories":["javascript"]},"headers":[],"relativePath":"blogs/javascript/jstips/20200103.md","filePath":"blogs/javascript/jstips/20200103.md"}'),l={name:"blogs/javascript/jstips/20200103.md"},h=n(`<h1 id="javascript对象属性的遍历顺序详解-🔄" tabindex="-1">JavaScript对象属性的遍历顺序详解 🔄 <a class="header-anchor" href="#javascript对象属性的遍历顺序详解-🔄" aria-label="Permalink to &quot;JavaScript对象属性的遍历顺序详解 🔄&quot;">​</a></h1><h2 id="问题引入-❓" tabindex="-1">问题引入 ❓ <a class="header-anchor" href="#问题引入-❓" aria-label="Permalink to &quot;问题引入 ❓&quot;">​</a></h2><p>在使用 <code>for...in</code> 或 Vue 的 <code>v-for</code> 遍历对象时，你可能会发现遍历顺序与属性的书写顺序不一致。这是为什么呢？让我们深入了解 JavaScript 对象属性的遍历规则。</p><h2 id="属性遍历顺序规则-📝" tabindex="-1">属性遍历顺序规则 📝 <a class="header-anchor" href="#属性遍历顺序规则-📝" aria-label="Permalink to &quot;属性遍历顺序规则 📝&quot;">​</a></h2><p>JavaScript 引擎在遍历对象属性时遵循以下顺序：</p><ol><li>首先遍历数字键（整数键），按照升序排列</li><li>然后遍历字符串键，按照属性被添加的顺序</li><li>最后遍历 Symbol 键，按照属性被添加的顺序</li></ol><h2 id="示例演示-🌟" tabindex="-1">示例演示 🌟 <a class="header-anchor" href="#示例演示-🌟" aria-label="Permalink to &quot;示例演示 🌟&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  n: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;a&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;1.1&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;4&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">5</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">  &#39;-2&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">6</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">7</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  [</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">Symbol</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;sym&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)]: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">8</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 输出顺序：</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 4</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// n</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// a</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1.1</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// -2</span></span></code></pre></div><h2 id="深入解析-🔍" tabindex="-1">深入解析 🔍 <a class="header-anchor" href="#深入解析-🔍" aria-label="Permalink to &quot;深入解析 🔍&quot;">​</a></h2><h3 id="为什么会这样排序" tabindex="-1">为什么会这样排序？ <a class="header-anchor" href="#为什么会这样排序" aria-label="Permalink to &quot;为什么会这样排序？&quot;">​</a></h3><ol><li><p><strong>整数键优先</strong>：</p><ul><li>JavaScript 引擎会优先处理可以转换为非负整数的键</li><li>这些键会按数值大小升序排列</li><li>这样做是为了优化数组操作的性能</li></ul></li><li><p><strong>字符串键次之</strong>：</p><ul><li>非整数的字符串键按照创建顺序排序</li><li>包括无法转换为整数的字符串（如 &#39;a&#39;）和小数字符串（如 &#39;1.1&#39;）</li></ul></li><li><p><strong>Symbol 键最后</strong>：</p><ul><li>Symbol 类型的键总是最后遍历</li><li>这是 ES6 后新增的特性</li></ul></li></ol><h2 id="实践建议-💡" tabindex="-1">实践建议 💡 <a class="header-anchor" href="#实践建议-💡" aria-label="Permalink to &quot;实践建议 💡&quot;">​</a></h2><ol><li><p><strong>不要依赖属性遍历顺序</strong>：</p><ul><li>在代码设计时，不要假设属性会按照特定顺序遍历</li><li>如果需要特定顺序，建议使用数组或 Map 对象</li></ul></li><li><p><strong>性能考虑</strong>：</p><ul><li>整数键的访问性能较好，因为引擎可以优化</li><li>但不要为了性能过度使用整数键，代码可读性更重要</li></ul></li></ol><h2 id="常见遍历方法对比-📊" tabindex="-1">常见遍历方法对比 📊 <a class="header-anchor" href="#常见遍历方法对比-📊" aria-label="Permalink to &quot;常见遍历方法对比 📊&quot;">​</a></h2><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> obj</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  b: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  a: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">  1</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">4</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">};</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 1. for...in</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">for</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> obj) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key);</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 2. Object.keys()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key));</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 3. Object.entries()</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">Object.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">entries</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(([</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">key</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">value</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(key));</span></span></code></pre></div><h2 id="注意事项-⚠️" tabindex="-1">注意事项 ⚠️ <a class="header-anchor" href="#注意事项-⚠️" aria-label="Permalink to &quot;注意事项 ⚠️&quot;">​</a></h2><ol><li><code>for...in</code> 会遍历原型链上的可枚举属性</li><li><code>Object.keys()</code> 只遍历对象自身的可枚举属性</li><li>如果需要固定顺序，建议使用 <code>Map</code> 对象</li><li>Vue 的 <code>v-for</code> 遍历对象时遵循相同的规则</li></ol><h2 id="总结-📌" tabindex="-1">总结 📌 <a class="header-anchor" href="#总结-📌" aria-label="Permalink to &quot;总结 📌&quot;">​</a></h2><p>理解对象属性的遍历顺序对于编写可靠的 JavaScript 代码很重要。虽然现代 JavaScript 引擎遵循一定的规则，但最佳实践是不要依赖这个顺序，而是使用更可控的数据结构来确保你需要的遍历顺序。</p>`,19),p=[h];function t(k,e,r,E,d,o){return a(),i("div",null,p)}const y=s(l,[["render",t]]);export{c as __pageData,y as default};
