<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <title>ğŸ¨ 3D æ¨¡å‹é¢„è§ˆå™¨ | Model Viewer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 100%);
      color: #e2e8f0;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      overflow: hidden;
    }

    #app {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr auto;
    }

    /* Header æ ·å¼ */
    header {
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(10px);
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
      padding: 12px 20px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .header-content {
      display: flex;
      align-items: center;
      justify-content: space-between;
      max-width: 1400px;
      margin: 0 auto;
    }

    .logo {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 18px;
      font-weight: 700;
      color: #60a5fa;
    }

    .controls {
      display: flex;
      gap: 12px;
      align-items: center;
      flex-wrap: wrap;
    }

    /* æ–‡ä»¶è¾“å…¥æ ·å¼ */
    .file-input-wrapper {
      position: relative;
      overflow: hidden;
      display: inline-block;
    }

    .file-input-wrapper input[type=file] {
      position: absolute;
      left: -9999px;
    }

    .file-input-label {
      background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
      color: white;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.3);
    }

    .file-input-label:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 20px rgba(59, 130, 246, 0.4);
    }

    /* æŒ‰é’®æ ·å¼ */
    button {
      background: rgba(71, 85, 105, 0.8);
      border: 1px solid rgba(148, 163, 184, 0.2);
      color: #e2e8f0;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      font-weight: 600;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button:hover:not(:disabled) {
      background: rgba(100, 116, 139, 0.9);
      border-color: rgba(148, 163, 184, 0.3);
      transform: translateY(-1px);
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      transform: none;
    }

    button.primary {
      background: linear-gradient(135deg, #10b981 0%, #059669 100%);
      border-color: #10b981;
      box-shadow: 0 4px 12px rgba(16, 185, 129, 0.2);
    }

    button.primary:hover:not(:disabled) {
      box-shadow: 0 6px 16px rgba(16, 185, 129, 0.3);
    }

    /* ä¸»è¦å†…å®¹åŒºåŸŸ */
    .main-content {
      position: relative;
      height: 100%;
      overflow: hidden;
    }

    #canvas-container {
      width: 100%;
      height: 100%;
      position: relative;
    }

    /* ä¾§è¾¹æ  */
    .sidebar {
      position: absolute;
      right: 0;
      top: 0;
      width: 320px;
      height: 100%;
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(10px);
      border-left: 1px solid rgba(148, 163, 184, 0.1);
      transform: translateX(100%);
      transition: transform 0.3s ease;
      z-index: 50;
      overflow-y: auto;
    }

    .sidebar.open {
      transform: translateX(0);
    }

    .sidebar-header {
      padding: 20px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.1);
      display: flex;
      align-items: center;
      justify-content: space-between;
    }

    .sidebar-content {
      padding: 20px;
    }

    .info-section {
      margin-bottom: 24px;
    }

    .info-section h3 {
      margin: 0 0 12px 0;
      color: #60a5fa;
      font-size: 16px;
      font-weight: 600;
    }

    .info-item {
      display: flex;
      justify-content: space-between;
      margin-bottom: 8px;
      font-size: 14px;
    }

    .info-label {
      color: #94a3b8;
    }

    .info-value {
      color: #e2e8f0;
      font-weight: 500;
    }

    /* æè´¨æ§åˆ¶ */
    .material-controls {
      display: grid;
      gap: 12px;
    }

    .control-group {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .control-group label {
      font-size: 12px;
      color: #94a3b8;
      font-weight: 500;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(71, 85, 105, 0.5);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #3b82f6;
      cursor: pointer;
      box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
    }

    input[type="color"] {
      width: 100%;
      height: 36px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
    }

    /* çŠ¶æ€æŒ‡ç¤ºå™¨ */
    .status-indicator {
      position: absolute;
      top: 20px;
      left: 20px;
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(148, 163, 184, 0.2);
      padding: 12px 16px;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      font-weight: 500;
      z-index: 10;
    }

    .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #64748b;
    }

    .status-dot.loading {
      background: #f59e0b;
      animation: pulse 1.5s infinite;
    }

    .status-dot.loaded {
      background: #10b981;
    }

    .status-dot.error {
      background: #ef4444;
    }

    @keyframes pulse {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    /* å·¥å…·æ  */
    .toolbar {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(8px);
      border: 1px solid rgba(148, 163, 184, 0.2);
      border-radius: 12px;
      padding: 8px;
      display: flex;
      gap: 4px;
      z-index: 10;
    }

    .toolbar button {
      padding: 8px;
      min-width: 40px;
      height: 40px;
      border-radius: 8px;
      background: transparent;
      border: none;
      color: #94a3b8;
      transition: all 0.2s ease;
    }

    .toolbar button:hover:not(:disabled) {
      background: rgba(71, 85, 105, 0.5);
      color: #e2e8f0;
      transform: none;
    }

    .toolbar button.active {
      background: #3b82f6;
      color: white;
    }

    /* åº•éƒ¨ä¿¡æ¯æ  */
    footer {
      background: rgba(15, 23, 42, 0.95);
      backdrop-filter: blur(10px);
      border-top: 1px solid rgba(148, 163, 184, 0.1);
      padding: 12px 20px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 12px;
      color: #64748b;
    }

    .footer-info {
      display: flex;
      gap: 20px;
      align-items: center;
    }

    /* å“åº”å¼è®¾è®¡ */
    @media (max-width: 768px) {
      .sidebar {
        width: 100%;
      }

      .controls {
        flex-direction: column;
        gap: 8px;
      }

      .header-content {
        flex-direction: column;
        gap: 12px;
      }
    }

    /* åŠ è½½åŠ¨ç”» */
    .loading-spinner {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 40px;
      height: 40px;
      border: 3px solid rgba(59, 130, 246, 0.3);
      border-top: 3px solid #3b82f6;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      z-index: 20;
    }

    @keyframes spin {
      0% {
        transform: translate(-50%, -50%) rotate(0deg);
      }

      100% {
        transform: translate(-50%, -50%) rotate(360deg);
      }
    }

    /* æ‹–æ‹½åŒºåŸŸ */
    .drop-zone {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(59, 130, 246, 0.1);
      border: 2px dashed #3b82f6;
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 30;
      flex-direction: column;
      gap: 12px;
      font-size: 18px;
      font-weight: 600;
      color: #3b82f6;
    }

    .drop-zone.active {
      display: flex;
    }
  </style>
</head>

<body>
  <div id="app">
    <header>
      <div class="header-content">
        <div class="logo">
          <span>ğŸ¨</span>
          <span>3D æ¨¡å‹é¢„è§ˆå™¨</span>
        </div>
        <div class="controls">
          <div class="file-input-wrapper">
            <input id="modelInput" type="file" accept=".obj,.mtl,.glb,.gltf,.fbx,.dae,.ply,.stl" />
            <label for="modelInput" class="file-input-label">
              <span>ğŸ“</span>
              <span>é€‰æ‹©æ¨¡å‹æ–‡ä»¶</span>
            </label>
          </div>
          <button id="resetCameraBtn" disabled>
            <span>ğŸ¯</span>
            <span>é‡ç½®è§†è§’</span>
          </button>
          <button id="toggleWireframeBtn" disabled>
            <span>ğŸ”—</span>
            <span>çº¿æ¡†æ¨¡å¼</span>
          </button>
          <button id="explodeBtn" disabled style="display: none;">
            <span>ğŸ’¥</span>
            <span>çˆ†ç‚¸æ¨¡å¼</span>
          </button>
          <button id="toggleSidebarBtn">
            <span>âš™ï¸</span>
            <span>è®¾ç½®é¢æ¿</span>
          </button>
        </div>
      </div>
    </header>

    <div class="main-content">
      <div id="canvas-container">
        <div class="status-indicator">
          <div id="statusDot" class="status-dot"></div>
          <span id="statusText">ç­‰å¾…åŠ è½½æ¨¡å‹æ–‡ä»¶...</span>
        </div>

        <div class="toolbar">
          <button id="rotateBtn" title="è‡ªåŠ¨æ—‹è½¬">ğŸ”„</button>
          <button id="fullscreenBtn" title="å…¨å±">ğŸ”³</button>
          <button id="screenshotBtn" title="æˆªå›¾" disabled>ğŸ“·</button>
          <button id="infoBtn" title="æ¨¡å‹ä¿¡æ¯" disabled>â„¹ï¸</button>
        </div>

        <div id="loadingSpinner" class="loading-spinner" style="display: none;"></div>
        <div id="dropZone" class="drop-zone">
          <span>ğŸ¯</span>
          <span>æ‹–æ‹½æ¨¡å‹æ–‡ä»¶åˆ°è¿™é‡Œ</span>
          <small>æ”¯æŒ OBJ, GLB, GLTF, FBX, DAE, PLY, STL æ ¼å¼</small>
        </div>
      </div>

      <div id="sidebar" class="sidebar">
        <div class="sidebar-header">
          <h2>æ¨¡å‹è®¾ç½®</h2>
          <button id="closeSidebarBtn" style="padding: 4px 8px; font-size: 16px;">âœ•</button>
        </div>
        <div class="sidebar-content">
          <div class="info-section">
            <h3>ğŸ“Š æ¨¡å‹ä¿¡æ¯</h3>
            <div class="info-item">
              <span class="info-label">æ–‡ä»¶å:</span>
              <span id="fileName" class="info-value">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">æ–‡ä»¶å¤§å°:</span>
              <span id="fileSize" class="info-value">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">é¡¶ç‚¹æ•°:</span>
              <span id="vertexCount" class="info-value">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">é¢æ•°:</span>
              <span id="faceCount" class="info-value">-</span>
            </div>
            <div class="info-item">
              <span class="info-label">æè´¨æ•°:</span>
              <span id="materialCount" class="info-value">-</span>
            </div>
          </div>

          <div class="info-section">
            <h3>ğŸ¨ å¤–è§‚è®¾ç½®</h3>
            <div class="material-controls">
              <div class="control-group">
                <label>ç¯å¢ƒå…‰å¼ºåº¦</label>
                <input type="range" id="ambientIntensity" min="0" max="2" step="0.1" value="0.6" />
              </div>
              <div class="control-group">
                <label>ä¸»å…‰æºå¼ºåº¦</label>
                <input type="range" id="lightIntensity" min="0" max="3" step="0.1" value="1.0" />
              </div>
              <div class="control-group">
                <label>æ¨¡å‹ä¸é€æ˜åº¦</label>
                <input type="range" id="modelOpacity" min="0" max="1" step="0.05" value="1.0" />
              </div>
              <div class="control-group">
                <label>èƒŒæ™¯é¢œè‰²</label>
                <input type="color" id="backgroundColor" value="#0f1419" />
              </div>
            </div>
          </div>

          <div class="info-section" id="explosionSection" style="display: none;">
            <h3>ğŸ’¥ çˆ†ç‚¸æ•ˆæœ</h3>
            <div class="material-controls">
              <div class="control-group">
                <label>çˆ†ç‚¸è·ç¦»</label>
                <input type="range" id="explosionDistance" min="0.3" max="2.0" step="0.1" value="0.8" />
              </div>
              <div class="control-group">
                <label>çˆ†ç‚¸é€Ÿåº¦</label>
                <input type="range" id="explosionSpeed" min="500" max="2000" step="100" value="1000" />
              </div>
              <div class="control-group">
                <label>æ‚¬æµ®å¼ºåº¦</label>
                <input type="range" id="floatingIntensity" min="0" max="2" step="0.1" value="1.0" />
              </div>
            </div>
          </div>

          <div class="info-section">
            <h3>ğŸ”§ æ¸²æŸ“é€‰é¡¹</h3>
            <div class="material-controls">
              <button id="resetMaterialBtn" class="primary" style="width: 100%;" disabled>
                é‡ç½®æè´¨è®¾ç½®
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>

    <footer>
      <div class="footer-info">
        <span>æ”¯æŒæ ¼å¼: OBJ, GLB, GLTF, FBX, DAE, PLY, STL</span>
        <span>å¿«æ·é”®: R-é‡ç½® | W-çº¿æ¡† | E-çˆ†ç‚¸ | ç©ºæ ¼-æ—‹è½¬ | F-å…¨å±</span>
        <span id="renderInfo">FPS: 0 | ä¸‰è§’å½¢: 0</span>
      </div>
      <div>
        <span>Powered by Three.js</span>
      </div>
    </footer>
  </div>

  <!-- å¤–éƒ¨ä¾èµ– -->
  <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
  <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.179.1/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.179.1/examples/jsm/controls/OrbitControls.js",
    "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/GLTFLoader.js",
    "three/examples/jsm/loaders/OBJLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/OBJLoader.js",
    "three/examples/jsm/loaders/MTLLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/MTLLoader.js",
    "three/examples/jsm/loaders/FBXLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/FBXLoader.js",
    "three/examples/jsm/loaders/ColladaLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/ColladaLoader.js",
    "three/examples/jsm/loaders/PLYLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/PLYLoader.js",
    "three/examples/jsm/loaders/STLLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/STLLoader.js",
    "three/examples/jsm/loaders/DRACOLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/DRACOLoader.js"
  }
}
</script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { OBJLoader } from "three/examples/jsm/loaders/OBJLoader.js";
    import { MTLLoader } from "three/examples/jsm/loaders/MTLLoader.js";
    import { FBXLoader } from "three/examples/jsm/loaders/FBXLoader.js";
    import { ColladaLoader } from "three/examples/jsm/loaders/ColladaLoader.js";
    import { PLYLoader } from "three/examples/jsm/loaders/PLYLoader.js";
    import { STLLoader } from "three/examples/jsm/loaders/STLLoader.js";
    import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader.js";

    // ğŸ¯ æ ¸å¿ƒå˜é‡å®šä¹‰
    let scene, camera, renderer, controls;
    let currentModel = null;
    let isAutoRotating = false;
    let isWireframeMode = false;
    let ambientLight, directionalLight;

    // ğŸ’¥ çˆ†ç‚¸åŠŸèƒ½ç›¸å…³å˜é‡
    let meshData = new Map();
    let modelCenter = new THREE.Vector3();
    let modelSize = new THREE.Vector3();
    let modelRadius = 1;
    let isExploded = false;
    let floatingEnabled = false;
    const clock = new THREE.Clock();

    // ğŸ“Š æ€§èƒ½ç›‘æ§
    let frameCount = 0;
    let lastTime = performance.now();
    let fps = 0;

    // ğŸ¨ UIå…ƒç´ å¼•ç”¨
    const elements = {
      modelInput: document.getElementById('modelInput'),
      resetCameraBtn: document.getElementById('resetCameraBtn'),
      toggleWireframeBtn: document.getElementById('toggleWireframeBtn'),
      explodeBtn: document.getElementById('explodeBtn'),
      toggleSidebarBtn: document.getElementById('toggleSidebarBtn'),
      closeSidebarBtn: document.getElementById('closeSidebarBtn'),
      sidebar: document.getElementById('sidebar'),
      statusDot: document.getElementById('statusDot'),
      statusText: document.getElementById('statusText'),
      loadingSpinner: document.getElementById('loadingSpinner'),
      dropZone: document.getElementById('dropZone'),
      rotateBtn: document.getElementById('rotateBtn'),
      fullscreenBtn: document.getElementById('fullscreenBtn'),
      screenshotBtn: document.getElementById('screenshotBtn'),
      infoBtn: document.getElementById('infoBtn'),
      // æ¨¡å‹ä¿¡æ¯
      fileName: document.getElementById('fileName'),
      fileSize: document.getElementById('fileSize'),
      vertexCount: document.getElementById('vertexCount'),
      faceCount: document.getElementById('faceCount'),
      materialCount: document.getElementById('materialCount'),
      // æ§åˆ¶å…ƒç´ 
      ambientIntensity: document.getElementById('ambientIntensity'),
      lightIntensity: document.getElementById('lightIntensity'),
      modelOpacity: document.getElementById('modelOpacity'),
      backgroundColor: document.getElementById('backgroundColor'),
      resetMaterialBtn: document.getElementById('resetMaterialBtn'),
      renderInfo: document.getElementById('renderInfo'),
      // çˆ†ç‚¸æ§åˆ¶å…ƒç´ 
      explosionSection: document.getElementById('explosionSection'),
      explosionDistance: document.getElementById('explosionDistance'),
      explosionSpeed: document.getElementById('explosionSpeed'),
      floatingIntensity: document.getElementById('floatingIntensity')
    };

    // ğŸš€ åˆå§‹åŒ– Three.js åœºæ™¯
    function initThreeJS() {
      // åˆ›å»ºåœºæ™¯
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0f1419);

      // åˆ›å»ºç›¸æœº
      camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.01,
        1000
      );
      camera.position.set(5, 5, 5);

      // åˆ›å»ºæ¸²æŸ“å™¨
      renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: false,
        powerPreference: 'high-performance'
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.outputEncoding = THREE.sRGBEncoding;
      renderer.toneMapping = THREE.ACESFilmicToneMapping;
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      document.getElementById('canvas-container').appendChild(renderer.domElement);

      // åˆ›å»ºæ§åˆ¶å™¨
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dampingFactor = 0.05;
      controls.screenSpacePanning = false;
      controls.minDistance = 0.1;
      controls.maxDistance = 100;

      // åˆ›å»ºå…‰æº
      ambientLight = new THREE.HemisphereLight(0xffffff, 0x444444, 0.6);
      scene.add(ambientLight);

      directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
      directionalLight.position.set(10, 10, 5);
      directionalLight.castShadow = true;
      directionalLight.shadow.mapSize.width = 2048;
      directionalLight.shadow.mapSize.height = 2048;
      scene.add(directionalLight);

      // åˆ›å»ºç½‘æ ¼åœ°é¢
      const gridHelper = new THREE.GridHelper(20, 20, 0x233244, 0x1b2433);
      gridHelper.material.opacity = 0.15;
      gridHelper.material.transparent = true;
      scene.add(gridHelper);

      console.log('âœ… Three.js åœºæ™¯åˆå§‹åŒ–å®Œæˆ');
    }

    // ğŸ“ å¤šæ ¼å¼åŠ è½½å™¨ç®¡ç†
    class ModelLoader {
      constructor() {
        this.loaders = new Map();
        this.initLoaders();
      }

      initLoaders() {
        // GLB/GLTF åŠ è½½å™¨
        const gltfLoader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        gltfLoader.setDRACOLoader(dracoLoader);
        this.loaders.set('gltf', gltfLoader);
        this.loaders.set('glb', gltfLoader);

        // OBJ åŠ è½½å™¨
        this.loaders.set('obj', new OBJLoader());

        // MTL åŠ è½½å™¨
        this.loaders.set('mtl', new MTLLoader());

        // FBX åŠ è½½å™¨
        this.loaders.set('fbx', new FBXLoader());

        // Collada åŠ è½½å™¨
        this.loaders.set('dae', new ColladaLoader());

        // PLY åŠ è½½å™¨
        this.loaders.set('ply', new PLYLoader());

        // STL åŠ è½½å™¨
        this.loaders.set('stl', new STLLoader());
      }

      async loadModel(file) {
        const extension = file.name.split('.').pop().toLowerCase();
        const loader = this.loaders.get(extension);

        if (!loader) {
          throw new Error(`ä¸æ”¯æŒçš„æ–‡ä»¶æ ¼å¼: .${extension}`);
        }

        const url = URL.createObjectURL(file);

        try {
          let result;

          if (extension === 'obj') {
            // OBJ æ–‡ä»¶å¯èƒ½éœ€è¦ MTL æè´¨æ–‡ä»¶
            result = await this.loadOBJWithMaterials(url, file);
          } else if (extension === 'gltf' || extension === 'glb') {
            const gltf = await loader.loadAsync(url);
            result = gltf.scene;
          } else if (extension === 'fbx') {
            result = await loader.loadAsync(url);
          } else if (extension === 'dae') {
            const collada = await loader.loadAsync(url);
            result = collada.scene;
          } else if (extension === 'ply' || extension === 'stl') {
            const geometry = await loader.loadAsync(url);
            const material = new THREE.MeshStandardMaterial({
              color: 0x888888,
              metalness: 0.1,
              roughness: 0.8
            });
            result = new THREE.Mesh(geometry, material);
          } else {
            result = await loader.loadAsync(url);
          }
          URL.revokeObjectURL(url);
          console.log('result', result);
          return result;
        } catch (error) {
          URL.revokeObjectURL(url);
          throw error;
        }
      }

      async loadOBJWithMaterials(objUrl, objFile) {
        const objLoader = this.loaders.get('obj');

        // å°è¯•æŸ¥æ‰¾åŒåçš„ MTL æ–‡ä»¶
        const baseName = objFile.name.replace(/\.[^/.]+$/, "");
        const mtlFileName = baseName + '.mtl';

        // è¿™é‡Œæˆ‘ä»¬å…ˆåŠ è½½ OBJï¼Œå¦‚æœéœ€è¦ MTL æ”¯æŒï¼Œç”¨æˆ·éœ€è¦åŒæ—¶é€‰æ‹©
        const object = await objLoader.loadAsync(objUrl);

        // ä¸º OBJ æ¨¡å‹æ·»åŠ é»˜è®¤æè´¨
        object.traverse((child) => {
          if (child.isMesh) {
            if (!child.material || child.material.type === 'MeshBasicMaterial') {
              child.material = new THREE.MeshStandardMaterial({
                color: 0x888888,
                metalness: 0.1,
                roughness: 0.8
              });
            }
            child.castShadow = true;
            child.receiveShadow = true;
          }
        });

        return object;
      }
    }

    const modelLoader = new ModelLoader();

    // ğŸ’¥ çˆ†ç‚¸åŠŸèƒ½æ ¸å¿ƒå®ç°
    function collectMeshes(root) {
      meshData.clear();
      let idx = 0;
      root.traverse(obj => {
        if (obj.isMesh) {
          obj.updateMatrixWorld(true);
          const startWorldPos = new THREE.Vector3().setFromMatrixPosition(obj.matrixWorld);
          const startQuat = new THREE.Quaternion().setFromRotationMatrix(obj.matrixWorld);
          const startLocalPos = obj.position.clone();
          meshData.set(obj, {
            startLocalPos,
            startQuat,
            startWorldPos,
            floatPhase: Math.random() * Math.PI * 2 + idx * 0.3,
            baseExplodedLocalPos: null,
            baseExplodedQuat: null,
          });
          idx++;
        }
      });
      console.log(`ğŸ” æ£€æµ‹åˆ° ${meshData.size} ä¸ªmeshç»„ä»¶`);
      return meshData.size;
    }

    function computeModelBounds(root) {
      const box = new THREE.Box3().setFromObject(root);
      box.getCenter(modelCenter);
      box.getSize(modelSize);
      modelRadius = modelSize.length() / 2;
    }

    function worldToLocalFor(mesh, worldPos) {
      const invParent = new THREE.Matrix4().copy(mesh.parent.matrixWorld).invert();
      return worldPos.clone().applyMatrix4(invParent);
    }

    function slerpTo(mesh, fromQ, toQ, t) {
      mesh.quaternion.slerp(toQ, t);
    }

    async function shakeRoot(duration = 500, amplitude = 0.03, rotAmp = 0.03) {
      return new Promise(resolve => {
        const start = { t: 0 };
        new TWEEN.Tween(start)
          .to({ t: 1 }, duration)
          .easing(TWEEN.Easing.Quadratic.InOut)
          .onUpdate(() => {
            const s = (1 - Math.abs(0.5 - start.t) * 2);
            currentModel.position.set(
              (Math.random() - 0.5) * amplitude * s,
              (Math.random() - 0.5) * amplitude * s,
              (Math.random() - 0.5) * amplitude * s
            );
            currentModel.rotation.set(
              (Math.random() - 0.5) * rotAmp * s,
              (Math.random() - 0.5) * rotAmp * s,
              (Math.random() - 0.5) * rotAmp * s
            );
          })
          .onComplete(() => {
            currentModel.position.set(0, 0, 0);
            currentModel.rotation.set(0, 0, 0);
            resolve();
          }).start();
      });
    }

    async function explodeModel() {
      if (!currentModel || meshData.size <= 1) return;

      const distanceFactor = parseFloat(elements.explosionDistance.value);
      const duration = parseInt(elements.explosionSpeed.value);

      updateStatus('loading', 'ğŸ’¥ æ‰§è¡Œçˆ†ç‚¸åŠ¨ç”»...');
      await shakeRoot();

      currentModel.updateMatrixWorld(true);
      computeModelBounds(currentModel);

      const tweens = [];
      meshData.forEach((data, mesh) => {
        if (!mesh.parent) return;
        mesh.parent.updateMatrixWorld(true);
        mesh.updateMatrixWorld(true);

        const worldPos = new THREE.Vector3().setFromMatrixPosition(mesh.matrixWorld);
        const dir = worldPos.clone().sub(modelCenter).normalize();
        const d = modelRadius * distanceFactor * (0.6 + 0.4 * (worldPos.distanceTo(modelCenter) / modelRadius));
        const targetWorldPos = worldPos.clone().addScaledVector(dir, d);
        const targetLocalPos = worldToLocalFor(mesh, targetWorldPos);

        // æ·»åŠ æ—‹è½¬åç§»
        const axis = dir.clone().cross(new THREE.Vector3(0, 1, 0));
        if (axis.lengthSq() < 1e-6) axis.set(1, 0, 0);
        axis.normalize();
        const angle = 0.35;
        const qOffset = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        const fromQ = mesh.quaternion.clone();
        const toQ = fromQ.clone().multiply(qOffset);

        data.baseExplodedLocalPos = targetLocalPos.clone();
        data.baseExplodedQuat = toQ.clone();

        // ä½ç½®åŠ¨ç”»
        tweens.push(new TWEEN.Tween(mesh.position)
          .to({ x: targetLocalPos.x, y: targetLocalPos.y, z: targetLocalPos.z }, duration)
          .easing(TWEEN.Easing.Back.Out)
          .start());

        // æ—‹è½¬åŠ¨ç”»
        const qParam = { t: 0 };
        tweens.push(new TWEEN.Tween(qParam)
          .to({ t: 1 }, duration)
          .easing(TWEEN.Easing.Back.Out)
          .onUpdate(() => slerpTo(mesh, fromQ, toQ, qParam.t))
          .start());
      });

      await waitTweens(tweens);
      floatingEnabled = true;
      isExploded = true;

      elements.explodeBtn.innerHTML = '<span>ğŸ”—</span><span>èšæ‹¢æ¨¡å¼</span>';
      updateStatus('loaded', 'ğŸ’¥ æ¨¡å‹å·²çˆ†ç‚¸ - éƒ¨ä»¶æ­£åœ¨æ‚¬æµ®');
    }

    async function assembleModel() {
      if (!currentModel || !isExploded) return;

      const duration = parseInt(elements.explosionSpeed.value) * 0.9;
      floatingEnabled = false;

      updateStatus('loading', 'ğŸ”— æ‰§è¡Œèšæ‹¢åŠ¨ç”»...');

      const tweens = [];
      meshData.forEach((data, mesh) => {
        const targetLocalPos = data.startLocalPos.clone();
        const targetQuat = data.startQuat.clone();

        tweens.push(new TWEEN.Tween(mesh.position)
          .to({ x: targetLocalPos.x, y: targetLocalPos.y, z: targetLocalPos.z }, duration)
          .easing(TWEEN.Easing.Cubic.InOut)
          .start());

        const qParam = { t: 0 };
        tweens.push(new TWEEN.Tween(qParam)
          .to({ t: 1 }, duration)
          .easing(TWEEN.Easing.Cubic.InOut)
          .onUpdate(() => slerpTo(mesh, mesh.quaternion, targetQuat, qParam.t))
          .start());
      });

      await waitTweens(tweens);
      isExploded = false;

      elements.explodeBtn.innerHTML = '<span>ğŸ’¥</span><span>çˆ†ç‚¸æ¨¡å¼</span>';
      updateStatus('loaded', 'ğŸ”— æ¨¡å‹å·²èšæ‹¢');
    }

    function waitTweens(tweens) {
      return new Promise(resolve => {
        if (tweens.length === 0) resolve();
        let finished = 0;
        tweens.forEach(t => t.onComplete(() => {
          finished++;
          if (finished >= tweens.length) resolve();
        }));
      });
    }

    function updateFloating(delta) {
      if (!floatingEnabled) return;
      const time = clock.getElapsedTime();
      const intensity = parseFloat(elements.floatingIntensity.value);

      meshData.forEach((data, mesh) => {
        const phase = data.floatPhase;
        const floatVector = new THREE.Vector3(
          Math.sin(time + phase),
          Math.cos(time + phase * 1.3),
          Math.sin(time + phase * 0.7)
        );
        mesh.position.addScaledVector(floatVector, 0.0007 * intensity);
        mesh.rotation.x += 0.0007 * intensity;
        mesh.rotation.y += 0.0009 * intensity;
      });
    }

    // ğŸ¨ æ¨¡å‹ç®¡ç†å’Œæ˜¾ç¤º
    function clearCurrentModel() {
      if (currentModel) {
        scene.remove(currentModel);

        // æ¸…ç†å‡ ä½•ä½“å’Œæè´¨
        currentModel.traverse((child) => {
          if (child.geometry) {
            child.geometry.dispose();
          }
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(material => material.dispose());
            } else {
              child.material.dispose();
            }
          }
        });

        currentModel = null;
      }

      // æ¸…ç†çˆ†ç‚¸ç›¸å…³æ•°æ®
      meshData.clear();
      floatingEnabled = false;
      isExploded = false;
      modelCenter.set(0, 0, 0);
      modelSize.set(0, 0, 0);
      modelRadius = 1;
    }

    function addModelToScene(model) {
      clearCurrentModel();

      currentModel = model;
      scene.add(currentModel);

      // è®¡ç®—æ¨¡å‹è¾¹ç•Œç›’å’Œå±…ä¸­
      const box = new THREE.Box3().setFromObject(currentModel);
      const center = box.getCenter(new THREE.Vector3());
      const size = box.getSize(new THREE.Vector3());

      // å±…ä¸­æ¨¡å‹
      currentModel.position.sub(center);

      // è°ƒæ•´ç›¸æœºä½ç½®ä»¥é€‚åº”æ¨¡å‹
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.5;

      camera.position.set(cameraZ, cameraZ * 0.7, cameraZ);
      camera.lookAt(0, 0, 0);
      controls.target.set(0, 0, 0);
      controls.update();

      // ğŸ” æ£€æµ‹meshæ•°é‡å¹¶å¯ç”¨çˆ†ç‚¸åŠŸèƒ½
      const meshCount = collectMeshes(currentModel);
      if (meshCount > 1) {
        elements.explodeBtn.style.display = 'flex';
        elements.explodeBtn.disabled = false;
        elements.explosionSection.style.display = 'block';
        console.log(`ğŸ‰ æ£€æµ‹åˆ° ${meshCount} ä¸ªmeshï¼Œçˆ†ç‚¸åŠŸèƒ½å·²å¯ç”¨`);
      } else {
        elements.explodeBtn.style.display = 'none';
        elements.explodeBtn.disabled = true;
        elements.explosionSection.style.display = 'none';
        console.log(`â„¹ï¸ åªæœ‰ ${meshCount} ä¸ªmeshï¼Œçˆ†ç‚¸åŠŸèƒ½ä¸å¯ç”¨`);
      }

      // æ›´æ–°æ¨¡å‹ä¿¡æ¯
      updateModelInfo(model);

      // å¯ç”¨ç›¸å…³æŒ‰é’®
      elements.resetCameraBtn.disabled = false;
      elements.toggleWireframeBtn.disabled = false;
      elements.screenshotBtn.disabled = false;
      elements.infoBtn.disabled = false;
      elements.resetMaterialBtn.disabled = false;

      console.log('âœ… æ¨¡å‹å·²åŠ è½½åˆ°åœºæ™¯');
    }

    // ğŸ“Š æ›´æ–°æ¨¡å‹ä¿¡æ¯
    function updateModelInfo(model) {
      let vertexCount = 0;
      let faceCount = 0;
      let materialCount = 0;
      const materials = new Set();

      model.traverse((child) => {
        if (child.isMesh && child.geometry) {
          const geometry = child.geometry;
          if (geometry.attributes.position) {
            vertexCount += geometry.attributes.position.count;
          }
          if (geometry.index) {
            faceCount += geometry.index.count / 3;
          } else if (geometry.attributes.position) {
            faceCount += geometry.attributes.position.count / 3;
          }

          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => materials.add(mat));
            } else {
              materials.add(child.material);
            }
          }
        }
      });

      materialCount = materials.size;

      elements.vertexCount.textContent = vertexCount.toLocaleString();
      elements.faceCount.textContent = Math.floor(faceCount).toLocaleString();
      elements.materialCount.textContent = materialCount;
    }

    // ğŸ® çŠ¶æ€ç®¡ç†
    function updateStatus(status, message) {
      elements.statusDot.className = `status-dot ${status}`;
      elements.statusText.textContent = message;
    }

    function showLoading(show = true) {
      elements.loadingSpinner.style.display = show ? 'block' : 'none';
    }

    // ğŸ“ æ–‡ä»¶å¤„ç†
    async function handleFile(file) {
      if (!file) return;

      updateStatus('loading', 'æ­£åœ¨åŠ è½½æ¨¡å‹...');
      showLoading(true);

      // æ›´æ–°æ–‡ä»¶ä¿¡æ¯
      elements.fileName.textContent = file.name;
      elements.fileSize.textContent = formatFileSize(file.size);

      try {
        const model = await modelLoader.loadModel(file);
        addModelToScene(model);
        updateStatus('loaded', 'æ¨¡å‹åŠ è½½æˆåŠŸ');
        showLoading(false);
      } catch (error) {
        console.error('âŒ æ¨¡å‹åŠ è½½å¤±è´¥:', error);
        updateStatus('error', `åŠ è½½å¤±è´¥: ${error.message}`);
        showLoading(false);
      }
    }

    function formatFileSize(bytes) {
      if (bytes === 0) return '0 Bytes';
      const k = 1024;
      const sizes = ['Bytes', 'KB', 'MB', 'GB'];
      const i = Math.floor(Math.log(bytes) / Math.log(k));
      return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    // ğŸ¯ ç›¸æœºæ§åˆ¶
    function resetCamera() {
      if (!currentModel) return;

      const box = new THREE.Box3().setFromObject(currentModel);
      const size = box.getSize(new THREE.Vector3());
      const maxDim = Math.max(size.x, size.y, size.z);
      const fov = camera.fov * (Math.PI / 180);
      let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2)) * 1.5;

      // ä½¿ç”¨ Tween.js åˆ›å»ºå¹³æ»‘çš„ç›¸æœºåŠ¨ç”»
      const startPos = camera.position.clone();
      const targetPos = new THREE.Vector3(cameraZ, cameraZ * 0.7, cameraZ);
      const startTarget = controls.target.clone();
      const targetTarget = new THREE.Vector3(0, 0, 0);

      new TWEEN.Tween({ t: 0 })
        .to({ t: 1 }, 1000)
        .easing(TWEEN.Easing.Cubic.Out)
        .onUpdate(({ t }) => {
          camera.position.lerpVectors(startPos, targetPos, t);
          controls.target.lerpVectors(startTarget, targetTarget, t);
          controls.update();
        })
        .start();
    }

    // ğŸ”— çº¿æ¡†æ¨¡å¼åˆ‡æ¢
    function toggleWireframe() {
      if (!currentModel) return;

      isWireframeMode = !isWireframeMode;

      currentModel.traverse((child) => {
        if (child.isMesh && child.material) {
          if (Array.isArray(child.material)) {
            child.material.forEach(mat => {
              mat.wireframe = isWireframeMode;
            });
          } else {
            child.material.wireframe = isWireframeMode;
          }
        }
      });

      elements.toggleWireframeBtn.textContent = isWireframeMode ? 'ğŸ”² å®ä½“æ¨¡å¼' : 'ğŸ”— çº¿æ¡†æ¨¡å¼';
    }

    // ğŸ”„ è‡ªåŠ¨æ—‹è½¬
    function toggleAutoRotate() {
      isAutoRotating = !isAutoRotating;
      controls.autoRotate = isAutoRotating;
      controls.autoRotateSpeed = 1.0;

      elements.rotateBtn.classList.toggle('active', isAutoRotating);
    }

    // ğŸ“· æˆªå›¾åŠŸèƒ½
    function takeScreenshot() {
      const link = document.createElement('a');
      link.download = 'model-screenshot.png';
      link.href = renderer.domElement.toDataURL();
      link.click();
    }

    // ğŸ”³ å…¨å±åŠŸèƒ½
    function toggleFullscreen() {
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen();
      } else {
        document.exitFullscreen();
      }
    }

    // ğŸ¨ æè´¨å’Œå…‰ç…§æ§åˆ¶
    function setupMaterialControls() {
      elements.ambientIntensity.addEventListener('input', (e) => {
        ambientLight.intensity = parseFloat(e.target.value);
      });

      elements.lightIntensity.addEventListener('input', (e) => {
        directionalLight.intensity = parseFloat(e.target.value);
      });

      elements.modelOpacity.addEventListener('input', (e) => {
        if (!currentModel) return;
        const opacity = parseFloat(e.target.value);

        currentModel.traverse((child) => {
          if (child.isMesh && child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => {
                mat.transparent = opacity < 1.0;
                mat.opacity = opacity;
              });
            } else {
              child.material.transparent = opacity < 1.0;
              child.material.opacity = opacity;
            }
          }
        });
      });

      elements.backgroundColor.addEventListener('input', (e) => {
        scene.background = new THREE.Color(e.target.value);
      });

      elements.resetMaterialBtn.addEventListener('click', () => {
        elements.ambientIntensity.value = 0.6;
        elements.lightIntensity.value = 1.0;
        elements.modelOpacity.value = 1.0;
        elements.backgroundColor.value = '#0f1419';

        ambientLight.intensity = 0.6;
        directionalLight.intensity = 1.0;
        scene.background = new THREE.Color(0x0f1419);

        if (currentModel) {
          currentModel.traverse((child) => {
            if (child.isMesh && child.material) {
              if (Array.isArray(child.material)) {
                child.material.forEach(mat => {
                  mat.transparent = false;
                  mat.opacity = 1.0;
                });
              } else {
                child.material.transparent = false;
                child.material.opacity = 1.0;
              }
            }
          });
        }
      });
    }

    // ğŸ“± æ‹–æ‹½æ”¯æŒ
    function setupDragAndDrop() {
      const container = document.getElementById('canvas-container');

      ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        container.addEventListener(eventName, preventDefaults, false);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      ['dragenter', 'dragover'].forEach(eventName => {
        container.addEventListener(eventName, () => {
          elements.dropZone.classList.add('active');
        }, false);
      });

      ['dragleave', 'drop'].forEach(eventName => {
        container.addEventListener(eventName, () => {
          elements.dropZone.classList.remove('active');
        }, false);
      });

      container.addEventListener('drop', (e) => {
        const dt = e.dataTransfer;
        const files = dt.files;

        if (files.length > 0) {
          handleFile(files[0]);
        }
      });
    }

    // ğŸ® äº‹ä»¶ç›‘å¬å™¨è®¾ç½®
    function setupEventListeners() {
      // æ–‡ä»¶è¾“å…¥
      elements.modelInput.addEventListener('change', (e) => {
        if (e.target.files.length > 0) {
          handleFile(e.target.files[0]);
        }
      });

      // æŒ‰é’®äº‹ä»¶
      elements.resetCameraBtn.addEventListener('click', resetCamera);
      elements.toggleWireframeBtn.addEventListener('click', toggleWireframe);
      elements.explodeBtn.addEventListener('click', async () => {
        if (isExploded) {
          await assembleModel();
        } else {
          await explodeModel();
        }
      });
      elements.rotateBtn.addEventListener('click', toggleAutoRotate);
      elements.fullscreenBtn.addEventListener('click', toggleFullscreen);
      elements.screenshotBtn.addEventListener('click', takeScreenshot);

      // ä¾§è¾¹æ æ§åˆ¶
      elements.toggleSidebarBtn.addEventListener('click', () => {
        elements.sidebar.classList.toggle('open');
      });

      elements.closeSidebarBtn.addEventListener('click', () => {
        elements.sidebar.classList.remove('open');
      });

      // çª—å£è°ƒæ•´
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // é”®ç›˜å¿«æ·é”®
      document.addEventListener('keydown', async (e) => {
        if (e.key === 'r' || e.key === 'R') {
          resetCamera();
        } else if (e.key === 'w' || e.key === 'W') {
          toggleWireframe();
        } else if (e.key === 'e' || e.key === 'E') {
          if (!elements.explodeBtn.disabled) {
            if (isExploded) {
              await assembleModel();
            } else {
              await explodeModel();
            }
          }
        } else if (e.key === ' ') {
          e.preventDefault();
          toggleAutoRotate();
        } else if (e.key === 'f' || e.key === 'F') {
          toggleFullscreen();
        }
      });
    }

    // ğŸ¬ åŠ¨ç”»å¾ªç¯
    function animate() {
      requestAnimationFrame(animate);

      // æ›´æ–°æ§åˆ¶å™¨
      controls.update();

      // æ›´æ–° Tween åŠ¨ç”»
      TWEEN.update();

      // ğŸ’¥ æ›´æ–°æ‚¬æµ®æ•ˆæœ
      updateFloating(clock.getDelta());

      // æ¸²æŸ“åœºæ™¯
      renderer.render(scene, camera);

      // æ›´æ–°æ€§èƒ½ä¿¡æ¯
      frameCount++;
      const currentTime = performance.now();
      if (currentTime - lastTime >= 1000) {
        fps = Math.round((frameCount * 1000) / (currentTime - lastTime));
        frameCount = 0;
        lastTime = currentTime;

        // æ›´æ–°æ¸²æŸ“ä¿¡æ¯
        const triangles = renderer.info.render.triangles;
        const meshCount = meshData.size;
        const statusText = isExploded ? ` | å·²çˆ†ç‚¸ (${meshCount}ä¸ªéƒ¨ä»¶)` : '';
        elements.renderInfo.textContent = `FPS: ${fps} | ä¸‰è§’å½¢: ${triangles.toLocaleString()}${statusText}`;
      }
    }

    // ğŸš€ åº”ç”¨åˆå§‹åŒ–
    function init() {
      console.log('ğŸ¨ åˆå§‹åŒ– 3D æ¨¡å‹é¢„è§ˆå™¨...');

      initThreeJS();
      setupEventListeners();
      setupMaterialControls();
      setupDragAndDrop();

      // å¼€å§‹åŠ¨ç”»å¾ªç¯
      animate();

      console.log('âœ… 3D æ¨¡å‹é¢„è§ˆå™¨åˆå§‹åŒ–å®Œæˆ');
      updateStatus('ready', 'å°±ç»ª - è¯·é€‰æ‹©æˆ–æ‹–æ‹½æ¨¡å‹æ–‡ä»¶');
    }

    // å¯åŠ¨åº”ç”¨
    init();
  </script>
</body>

</html>