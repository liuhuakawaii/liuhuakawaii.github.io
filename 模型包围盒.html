<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D模型加载与包围盒编辑</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      font-family: sans-serif;
      background-color: #1a1a1a;
    }

    #canvas-container {
      width: 100vw;
      height: 100vh;
    }

    #ui-panel {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 10;
    }

    button,
    input[type="file"] {
      padding: 8px;
      border-radius: 4px;
      border: none;
      cursor: pointer;
      font-size: 14px;
    }

    button {
      background-color: #4CAF50;
      color: white;
      transition: 0.3s;
    }

    button:hover {
      background-color: #45a049;
    }

    button.active {
      background-color: #e69500;
    }

    .info-text {
      font-size: 12px;
      color: #aaa;
    }
  </style>

  <!-- 使用 Import map 引入 Three.js -->
  <script type="importmap">
        {
            "imports": {
                "three": "https://esm.sh/three@0.160.0",
                "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>

<body>

  <div id="ui-panel">
    <h3>模型裁剪编辑器</h3>
    <div>
      <label class="info-text">1. 上传模型 (.glb/.gltf)</label>
      <input type="file" id="file-input" accept=".glb, .gltf">
    </div>

    <button id="toggle-edit-btn" disabled>开启编辑模式</button>
    <button id="print-btn" disabled>打印包围盒信息 (归一化)</button>
    <div id="output" class="info-text" style="white-space: pre-wrap;"></div>
  </div>

  <div id="canvas-container"></div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

    // --- 全局变量 ---
    let scene, camera, renderer, controls;
    let loadedModel = null;
    let modelBox = new THREE.Box3(); // 模型的原始包围盒

    // 编辑器相关
    let isEditMode = false;
    let selectionBoxData = { min: new THREE.Vector3(), max: new THREE.Vector3() };
    let selectionMeshGroup = new THREE.Group(); // 包含可视化的盒子和手柄
    let boxVisualMesh; // 半透明的盒子
    let handles = {}; // 存储6个面的手柄 Mesh

    // 交互相关
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    let activeHandle = null; // 当前拖拽的手柄
    let dragPlane = new THREE.Plane(); // 拖拽时使用的虚拟平面
    let dragOffset = new THREE.Vector3();

    init();
    animate();

    function init() {
      // 1. 基础场景设置
      const container = document.getElementById('canvas-container');
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x222222);

      // 灯光
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      const dirLight = new THREE.DirectionalLight(0xffffff, 1);
      dirLight.position.set(5, 10, 7);
      scene.add(dirLight);

      // 相机
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.set(5, 5, 5);

      // 渲染器
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(window.devicePixelRatio);
      container.appendChild(renderer.domElement);

      // 控制器
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // 2. 初始化选择框（一开始隐藏）
      initSelectionBox();

      // 3. 事件监听
      window.addEventListener('resize', onWindowResize);

      // UI 事件
      document.getElementById('file-input').addEventListener('change', handleFileUpload);
      document.getElementById('toggle-edit-btn').addEventListener('click', toggleEditMode);
      document.getElementById('print-btn').addEventListener('click', printNormalizedInfo);

      // 鼠标交互事件
      renderer.domElement.addEventListener('pointerdown', onPointerDown);
      renderer.domElement.addEventListener('pointermove', onPointerMove);
      renderer.domElement.addEventListener('pointerup', onPointerUp);
    }

    // --- 模型加载逻辑 ---
    function handleFileUpload(event) {
      const file = event.target.files[0];
      if (!file) return;

      const url = URL.createObjectURL(file);
      const loader = new GLTFLoader();

      loader.load(url, (gltf) => {
        // 清理旧模型
        if (loadedModel) scene.remove(loadedModel);

        loadedModel = gltf.scene;
        scene.add(loadedModel);

        // 计算模型包围盒并居中
        const box = new THREE.Box3().setFromObject(loadedModel);
        const center = box.getCenter(new THREE.Vector3());
        const size = box.getSize(new THREE.Vector3());

        // 将模型居中到世界坐标原点，方便后续计算
        loadedModel.position.x += (loadedModel.position.x - center.x);
        loadedModel.position.y += (loadedModel.position.y - center.y);
        loadedModel.position.z += (loadedModel.position.z - center.z);

        // 更新 modelBox 为居中后的包围盒
        modelBox.setFromObject(loadedModel);

        // 调整相机视角
        const maxDim = Math.max(size.x, size.y, size.z);
        camera.position.set(maxDim * 1.5, maxDim * 1.5, maxDim * 2);
        controls.target.set(0, 0, 0);
        controls.update();

        // 重置选择框数据为整个模型
        selectionBoxData.min.copy(modelBox.min);
        selectionBoxData.max.copy(modelBox.max);
        updateSelectionBoxVisuals();

        // 启用按钮
        document.getElementById('toggle-edit-btn').disabled = false;
        document.getElementById('print-btn').disabled = false;
        document.getElementById('output').textContent = "模型加载成功";

        URL.revokeObjectURL(url);
      }, undefined, (error) => {
        console.error(error);
        alert('模型加载失败，请检查文件格式');
      });
    }

    // --- 选择框逻辑 ---
    function initSelectionBox() {
      scene.add(selectionMeshGroup);
      selectionMeshGroup.visible = false;

      // 1. 视觉盒子 (半透明红色)
      const geometry = new THREE.BoxGeometry(1, 1, 1);
      const material = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        transparent: true,
        opacity: 0.2,
        depthTest: false // 保证始终可见
      });
      boxVisualMesh = new THREE.Mesh(geometry, material);

      // 边框辅助线
      const edges = new THREE.EdgesGeometry(geometry);
      const line = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0xff0000 }));
      boxVisualMesh.add(line);

      selectionMeshGroup.add(boxVisualMesh);

      // 2. 创建6个面的手柄
      const handleGeo = new THREE.BoxGeometry(1, 1, 1);
      const handleMat = new THREE.MeshBasicMaterial({ color: 0xffff00 }); // 黄色手柄

      const directions = ['x+', 'x-', 'y+', 'y-', 'z+', 'z-'];

      directions.forEach(dir => {
        const handle = new THREE.Mesh(handleGeo, handleMat);
        handle.name = `handle_${dir}`;
        selectionMeshGroup.add(handle);
        handles[dir] = handle;
      });
    }

    function updateSelectionBoxVisuals() {
      if (!loadedModel) return;

      const min = selectionBoxData.min;
      const max = selectionBoxData.max;

      const width = max.x - min.x;
      const height = max.y - min.y;
      const depth = max.z - min.z;

      const centerX = min.x + width / 2;
      const centerY = min.y + height / 2;
      const centerZ = min.z + depth / 2;

      // 更新可视盒子
      boxVisualMesh.position.set(centerX, centerY, centerZ);
      boxVisualMesh.scale.set(width, height, depth);

      // 手柄大小 (根据模型大小自适应，避免太小或太大)
      const handleSize = Math.max(width, height, depth) * 0.05;

      // 更新手柄位置
      // X+ (Right)
      handles['x+'].position.set(max.x, centerY, centerZ);
      handles['x+'].scale.set(handleSize / 4, handleSize, handleSize);

      // X- (Left)
      handles['x-'].position.set(min.x, centerY, centerZ);
      handles['x-'].scale.set(handleSize / 4, handleSize, handleSize);

      // Y+ (Top)
      handles['y+'].position.set(centerX, max.y, centerZ);
      handles['y+'].scale.set(handleSize, handleSize / 4, handleSize);

      // Y- (Bottom)
      handles['y-'].position.set(centerX, min.y, centerZ);
      handles['y-'].scale.set(handleSize, handleSize / 4, handleSize);

      // Z+ (Front)
      handles['z+'].position.set(centerX, centerY, max.z);
      handles['z+'].scale.set(handleSize, handleSize, handleSize / 4);

      // Z- (Back)
      handles['z-'].position.set(centerX, centerY, min.z);
      handles['z-'].scale.set(handleSize, handleSize, handleSize / 4);
    }

    // --- 交互与拖拽逻辑 ---

    function toggleEditMode() {
      isEditMode = !isEditMode;
      const btn = document.getElementById('toggle-edit-btn');

      if (isEditMode) {
        btn.textContent = "退出编辑模式";
        btn.classList.add('active');
        selectionMeshGroup.visible = true;
        // 重置选框到当前模型大小
        if (loadedModel) {
          // 保持上次编辑的状态，如果需要重置，可以在这里重新设置 selectionBoxData
        }
      } else {
        btn.textContent = "开启编辑模式";
        btn.classList.remove('active');
        selectionMeshGroup.visible = false;
      }
    }

    function onPointerDown(event) {
      if (!isEditMode) return;

      event.preventDefault();

      // 计算鼠标位置
      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);

      // 检测是否点击了手柄
      const handleMeshes = Object.values(handles);
      const intersects = raycaster.intersectObjects(handleMeshes);

      if (intersects.length > 0) {
        controls.enabled = false; // 禁用轨道控制，开始拖拽
        activeHandle = intersects[0].object;

        // 确定拖拽平面的法线
        // 如果拖拽 X 轴手柄，我们在 XY 平面还是 XZ 平面拖拽？
        // 为了简单，我们让拖拽射线与相机的视线方向相交，或者构建一个面向相机的平面。
        // 更精准的方法：如果动 X，构建一个法线为 Z 或 Y 的平面（取决于相机角度）。
        // 这里使用最简单的：构建一个法线朝向相机的平面通过点击点。

        const normal = new THREE.Vector3();

        // 根据手柄名称决定限制轴
        const name = activeHandle.name;
        if (name.includes('x')) normal.set(0, 0, 1); // 默认在 XY 平面拖
        else if (name.includes('y')) normal.set(0, 0, 1);
        else if (name.includes('z')) normal.set(0, 1, 0); // 在 XZ 平面拖

        // 如果相机和该平面太平行，换一个轴
        const viewDir = new THREE.Vector3();
        camera.getWorldDirection(viewDir);
        if (Math.abs(viewDir.dot(normal)) < 0.3) {
          if (name.includes('x')) normal.set(0, 1, 0);
          else if (name.includes('y')) normal.set(1, 0, 0);
          else if (name.includes('z')) normal.set(1, 0, 0);
        }

        dragPlane.setFromNormalAndCoplanarPoint(normal, intersects[0].point);
      }
    }

    function onPointerMove(event) {
      if (!activeHandle || !isEditMode) return;

      const rect = renderer.domElement.getBoundingClientRect();
      mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
      mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

      raycaster.setFromCamera(mouse, camera);
      const intersectPoint = new THREE.Vector3();

      if (raycaster.ray.intersectPlane(dragPlane, intersectPoint)) {
        const type = activeHandle.name.split('_')[1]; // e.g., "x+"

        // 限制：只能移动对应的轴，并且不能越过对面的边界
        // 添加一点 epsilon 防止完全重合
        const limitEpsilon = 0.01;

        switch (type) {
          case 'x+':
            selectionBoxData.max.x = Math.max(intersectPoint.x, selectionBoxData.min.x + limitEpsilon);
            break;
          case 'x-':
            selectionBoxData.min.x = Math.min(intersectPoint.x, selectionBoxData.max.x - limitEpsilon);
            break;
          case 'y+':
            selectionBoxData.max.y = Math.max(intersectPoint.y, selectionBoxData.min.y + limitEpsilon);
            break;
          case 'y-':
            selectionBoxData.min.y = Math.min(intersectPoint.y, selectionBoxData.max.y - limitEpsilon);
            break;
          case 'z+':
            selectionBoxData.max.z = Math.max(intersectPoint.z, selectionBoxData.min.z + limitEpsilon);
            break;
          case 'z-':
            selectionBoxData.min.z = Math.min(intersectPoint.z, selectionBoxData.max.z - limitEpsilon);
            break;
        }

        updateSelectionBoxVisuals();
      }
    }

    function onPointerUp() {
      activeHandle = null;
      controls.enabled = true; // 恢复相机控制
    }

    // --- 归一化计算 ---
    function printNormalizedInfo() {
      if (!loadedModel) return;

      const mMin = modelBox.min;
      const mMax = modelBox.max;
      const size = new THREE.Vector3();
      modelBox.getSize(size);

      const sMin = selectionBoxData.min;
      const sMax = selectionBoxData.max;

      // 计算归一化坐标 (相对于模型原始 Box 的 0-1 范围)
      // 公式: normVal = (currentVal - modelMin) / modelSize

      const normMin = {
        x: (sMin.x - mMin.x) / size.x,
        y: (sMin.y - mMin.y) / size.y,
        z: (sMin.z - mMin.z) / size.z
      };

      const normMax = {
        x: (sMax.x - mMin.x) / size.x,
        y: (sMax.y - mMin.y) / size.y,
        z: (sMax.z - mMin.z) / size.z
      };

      // 格式化输出
      const resultStr = `
【包围盒信息】
世界坐标:
  Min: (${sMin.x.toFixed(2)}, ${sMin.y.toFixed(2)}, ${sMin.z.toFixed(2)})
  Max: (${sMax.x.toFixed(2)}, ${sMax.y.toFixed(2)}, ${sMax.z.toFixed(2)})

归一化坐标 (0.0 - 1.0):
  Min: [${normMin.x.toFixed(4)}, ${normMin.y.toFixed(4)}, ${normMin.z.toFixed(4)}]
  Max: [${normMax.x.toFixed(4)}, ${normMax.y.toFixed(4)}, ${normMax.z.toFixed(4)}]
            `.trim();

      console.log(resultStr);
      document.getElementById('output').textContent = resultStr;
      alert("信息已打印到控制台和左上角面板");
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
  </script>
</body>

</html>