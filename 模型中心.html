<!DOCTYPE html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GLB è°ƒè¯•å™¨ â€” æ¨¡å‹ä¸­å¿ƒ/åŸç‚¹å­¦ä¹ å·¥å…·</title>
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    }

    #app {
      display: flex;
      height: 100vh;
    }

    #left {
      width: 380px;
      min-width: 280px;
      max-width: 480px;
      background: #0f1724;
      color: #e6eef8;
      padding: 12px;
      box-sizing: border-box;
      overflow: auto;
    }

    #viewer {
      flex: 1;
      position: relative;
      background: #111827;
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    h1 {
      font-size: 16px;
      margin: 6px 0 12px 0;
      color: #fff;
    }

    label,
    button {
      font-size: 13px;
    }

    .control {
      margin-bottom: 10px;
    }

    .btn {
      display: inline-block;
      background: #0ea5a5;
      color: #012;
      padding: 6px 10px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
      margin-right: 6px
    }

    .btn.alt {
      background: #7c3aed;
      color: white;
    }

    .btn.warn {
      background: #f97316;
      color: white;
    }

    .small {
      font-size: 12px;
      color: #cbd5e1;
    }

    .node-list {
      font-family: monospace;
      background: #071025;
      padding: 8px;
      border-radius: 6px;
      max-height: 280px;
      overflow: auto;
    }

    .node-item {
      padding: 6px;
      border-radius: 4px;
      cursor: pointer;
    }

    .node-item:hover {
      background: #07243a;
    }

    .selected {
      background: #134e4a;
    }

    .label {
      position: absolute;
      pointer-events: none;
      transform: translate(-50%, -120%);
      padding: 4px 8px;
      border-radius: 6px;
      font-size: 12px;
      background: rgba(0, 0, 0, 0.6);
      color: #fff;
      white-space: nowrap;
    }

    .legend {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }

    .sw {
      width: 12px;
      height: 12px;
      border-radius: 3px;
      display: inline-block;
    }

    .sw.red {
      background: #ef4444;
    }

    /* pivot */
    .sw.blue {
      background: #3b82f6;
    }

    /* bbox center */
    .sw.green {
      background: #10b981;
    }

    /* scene origin */
    .footer {
      margin-top: 14px;
      font-size: 12px;
      color: #9aa7b2;
    }

    input[type="text"] {
      width: 100%;
      padding: 8px;
      border-radius: 6px;
      border: 1px solid #18303b;
      background: #061018;
      color: #dbeafe;
      margin-top: 6px;
      box-sizing: border-box;
    }

    input[type="file"] {
      color: #dbeafe;
    }

    .row {
      display: flex;
      gap: 6px;
      align-items: center;
      margin-bottom: 8px;
    }

    .info {
      font-size: 12px;
      color: #9aa7b2;
      margin-top: 6px;
    }

    .toggle {
      cursor: pointer;
      padding: 4px 8px;
      border-radius: 6px;
      background: #072234;
      color: #9ccfd8;
      display: inline-block;
    }

    .concept-box {
      background: #1a2332;
      border-left: 3px solid #0ea5a5;
      padding: 10px;
      margin: 10px 0;
      border-radius: 6px;
    }

    .concept-title {
      font-weight: bold;
      color: #0ea5a5;
      margin-bottom: 6px;
      font-size: 14px;
    }

    .formula {
      background: #0a1420;
      padding: 8px;
      border-radius: 4px;
      font-family: 'Courier New', monospace;
      font-size: 12px;
      color: #fbbf24;
      margin: 6px 0;
      overflow-x: auto;
    }

    .step-box {
      background: #162536;
      padding: 8px;
      margin: 6px 0;
      border-radius: 4px;
      font-size: 12px;
    }

    .step-title {
      color: #60a5fa;
      font-weight: bold;
      margin-bottom: 4px;
    }

    .highlight {
      color: #fbbf24;
      font-weight: bold;
    }

    .section-title {
      font-size: 14px;
      font-weight: bold;
      color: #0ea5a5;
      margin: 14px 0 8px 0;
      padding-bottom: 4px;
      border-bottom: 1px solid #1a2332;
    }

    .calc-result {
      background: #0f2e3a;
      padding: 6px 8px;
      border-radius: 4px;
      margin: 4px 0;
      font-size: 12px;
      border-left: 2px solid #10b981;
    }

    code {
      background: #0a1420;
      padding: 2px 6px;
      border-radius: 3px;
      font-family: 'Courier New', monospace;
      color: #fbbf24;
      font-size: 11px;
    }
  </style>
  <!-- ä½¿ç”¨ Import map å¼•å…¥ Three.js -->
  <script type="importmap">
          {
              "imports": {
                  "three": "https://esm.sh/three@0.160.0",
                  "three/addons/": "https://esm.sh/three@0.160.0/examples/jsm/"
              }
          }
      </script>
</head>

<body>
  <div id="app">
    <div id="left">
      <h1>ğŸ“ 3Dæ¨¡å‹ä¸­å¿ƒ/åŸç‚¹å­¦ä¹ å·¥å…·</h1>

      <div class="section-title">ğŸ¯ æ ¸å¿ƒæ¦‚å¿µè¯´æ˜</div>

      <div class="concept-box">
        <div class="concept-title">1ï¸âƒ£ Local Origin (å±€éƒ¨åŸç‚¹ / Pivot)</div>
        <div class="small">èŠ‚ç‚¹è‡ªèº«åæ ‡ç³»çš„åŸç‚¹ (0,0,0)</div>
        <div class="formula">ä¸–ç•Œåæ ‡ = node.localToWorld(Vector3(0,0,0))</div>
        <div class="small" style="margin-top:4px">
          ğŸ’¡ è¿™æ˜¯èŠ‚ç‚¹çš„"é”šç‚¹"ï¼Œæ‰€æœ‰å˜æ¢ï¼ˆæ—‹è½¬ã€ç¼©æ”¾ï¼‰éƒ½å›´ç»•è¿™ä¸ªç‚¹è¿›è¡Œã€‚
        </div>
      </div>

      <div class="concept-box">
        <div class="concept-title">2ï¸âƒ£ BBox Center (åŒ…å›´ç›’ä¸­å¿ƒ)</div>
        <div class="small">èŠ‚ç‚¹åŠå…¶å­èŠ‚ç‚¹æ‰€æœ‰é¡¶ç‚¹çš„AABBä¸­å¿ƒ</div>
        <div class="formula">
          box = Box3().setFromObject(node)<br />
          center = (box.min + box.max) / 2
        </div>
        <div class="small" style="margin-top:4px">
          ğŸ’¡ è¿™æ˜¯å‡ ä½•ä½“çš„"è§†è§‰ä¸­å¿ƒ"ï¼Œä¸å—èŠ‚ç‚¹å˜æ¢å½±å“ã€‚
        </div>
      </div>

      <div class="concept-box">
        <div class="concept-title">3ï¸âƒ£ Scene Origin (ä¸–ç•ŒåŸç‚¹)</div>
        <div class="small">æ•´ä¸ª3Dåœºæ™¯çš„ç»å¯¹åŸç‚¹</div>
        <div class="formula">ä¸–ç•Œåæ ‡ = Vector3(0, 0, 0)</div>
        <div class="small" style="margin-top:4px">
          ğŸ’¡ æ‰€æœ‰å¯¹è±¡çš„ä¸–ç•Œåæ ‡éƒ½ç›¸å¯¹äºè¿™ä¸ªç‚¹ã€‚
        </div>
      </div>

      <div class="section-title">ğŸ“¦ åŠ è½½æ¨¡å‹</div>
      <div class="control">
        <div class="row">
          <input id="urlInput" type="text" placeholder="è¾“å…¥ .glb/.gltf URL" />
          <button id="loadUrl" class="btn">Load</button>
        </div>
        <div class="row">
          <input id="fileInput" type="file" accept=".glb,.gltf" />
        </div>
        <div class="info">ğŸ’¡ æ”¯æŒæ‹–æ‹½æ–‡ä»¶åˆ°å³ä¾§è§†å›¾</div>
      </div>

      <div class="section-title">ğŸ¨ å¯è§†åŒ–æ§åˆ¶</div>
      <div class="control">
        <div style="display: flex; gap: 6px; flex-wrap: wrap;">
          <button id="toggleBBoxHelper" class="btn alt">åŒ…å›´ç›’</button>
          <button id="toggleAxes" class="btn">åæ ‡è½´</button>
          <button id="toggleMarkers" class="btn">æ ‡è®°ç‚¹</button>
          <button id="toggleLocalAxes" class="btn">å±€éƒ¨åæ ‡ç³»</button>
        </div>
        <div style="margin-top:8px">
          <button id="autoCenter" class="btn warn">å±…ä¸­åˆ°BBoxä¸­å¿ƒ</button>
        </div>
      </div>

      <div class="section-title">ğŸŒ³ èŠ‚ç‚¹æ ‘</div>
      <div class="control">
        <div class="small">ç‚¹å‡»èŠ‚ç‚¹æŸ¥çœ‹è¯¦ç»†è®¡ç®—è¿‡ç¨‹</div>
        <div class="node-list" id="nodeList">ï¼ˆåŠ è½½æ¨¡å‹åæ˜¾ç¤ºï¼‰</div>
        <div style="margin-top:8px">
          <button id="findFirstMesh" class="btn">å®šä½ç¬¬ä¸€ä¸ªMesh</button>
          <button id="resetTransforms" class="btn alt">é‡ç½®å˜æ¢</button>
        </div>
      </div>

      <div class="section-title">ğŸ“Š è¯¦ç»†è®¡ç®—è¿‡ç¨‹</div>
      <div class="control">
        <div id="selectedInfo" style="font-size: 12px;">æœªé€‰æ‹©èŠ‚ç‚¹</div>
      </div>

      <div class="section-title">ğŸ¨ é¢œè‰²å›¾ä¾‹</div>
      <div class="control">
        <div class="legend">
          <div><span class="sw red"></span> Local Origin (çº¢)</div>
          <div><span class="sw blue"></span> BBox Center (è“)</div>
          <div><span class="sw green"></span> Scene Origin (ç»¿)</div>
        </div>
      </div>

      <div class="footer">
        <div class="section-title">ğŸ“– ä½¿ç”¨æŒ‡å—</div>
        <ol style="padding-left:16px; font-size: 12px;">
          <li>åŠ è½½ä¸€ä¸ª GLB/GLTF æ¨¡å‹</li>
          <li>åœ¨èŠ‚ç‚¹æ ‘ä¸­é€‰æ‹©èŠ‚ç‚¹</li>
          <li>æŸ¥çœ‹å³ä¾§çš„ä¸‰ä¸ªæ ‡è®°ç‚¹å’Œè¯¦ç»†è®¡ç®—è¿‡ç¨‹</li>
          <li>å¯¹æ¯” Local Origin å’Œ BBox Center çš„åŒºåˆ«</li>
          <li>ä½¿ç”¨"å±…ä¸­"æŒ‰é’®ä½“éªŒåæ ‡å˜æ¢</li>
        </ol>
        <div class="small" style="margin-top:8px; color: #64748b;">
          ğŸ’¡ æç¤ºï¼šå¾ˆå¤šå»ºæ¨¡è½¯ä»¶ï¼ˆå¦‚Blenderï¼‰å¯¼å‡ºæ—¶ï¼Œæ¨¡å‹çš„Local Originå¯èƒ½ä¸åœ¨å‡ ä½•ä¸­å¿ƒã€‚
          è¿™ä¸ªå·¥å…·å¸®åŠ©ä½ ç†è§£å’Œè°ƒè¯•è¿™ç§æƒ…å†µã€‚
        </div>
      </div>
    </div>

    <div id="viewer">
      <div id="labelPivot" class="label" style="display:none"><strong>Pivot</strong>
        <div class="small" id="pivotText"></div>
      </div>
      <div id="labelBBox" class="label" style="display:none"><strong>BBox Center</strong>
        <div class="small" id="bboxText"></div>
      </div>
      <div id="labelScene" class="label" style="display:none"><strong>Scene Origin</strong>
        <div class="small" id="sceneText">0,0,0</div>
      </div>
    </div>
  </div>

  <!-- three + gltfloader modules (ESM) -->
  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    // import { Box3Helper } from 'three/addons/helpers/Box3Helper.js';
    // import { BoxHelper } from 'three/addons/helpers/BoxHelper.js';
    import { TransformControls } from 'three/addons/controls/TransformControls.js';

    const container = document.getElementById('viewer');
    const labelPivot = document.getElementById('labelPivot');
    const labelBBox = document.getElementById('labelBBox');
    const labelScene = document.getElementById('labelScene');
    const pivotText = document.getElementById('pivotText');
    const bboxText = document.getElementById('bboxText');

    let scene, camera, renderer, controls;
    let loadedRoot = null; // gltf.scene
    let currentSelected = null;
    let boxHelper = null;
    let bboxCenterSphere = null;
    let pivotSphere = null;
    let sceneOriginSphere = null;
    let bboxHelperVisible = true;
    let markersVisible = true;
    let axesHelper = null;
    let localAxesHelper = null;
    let localAxesVisible = true;

    init();
    animate();

    function init() {
      // renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(container.clientWidth, container.clientHeight);
      container.appendChild(renderer.domElement);

      // scene & camera
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0b1220);
      camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.01, 2000);
      camera.position.set(3, 2, 4);

      // controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;

      // lights
      const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 1.0);
      hemi.position.set(0, 10, 0);
      scene.add(hemi);
      const dir = new THREE.DirectionalLight(0xffffff, 0.8);
      dir.position.set(3, 10, 5);
      scene.add(dir);

      // grid & axes helper
      const grid = new THREE.GridHelper(10, 20, 0x1f2937, 0x0f1724);
      scene.add(grid);

      axesHelper = new THREE.AxesHelper(1.5);
      scene.add(axesHelper);

      // scene origin marker (green)
      sceneOriginSphere = createMarkerSphere(0.05, 0x10b981);
      sceneOriginSphere.position.set(0, 0, 0);
      scene.add(sceneOriginSphere);
      labelScene.style.display = 'block';

      // interactions
      window.addEventListener('resize', onWindowResize);
      setupUI();
    }

    // UI wiring
    function setupUI() {
      const fileInput = document.getElementById('fileInput');
      const loadUrlBtn = document.getElementById('loadUrl');
      const urlInput = document.getElementById('urlInput');
      const toggleBBoxBtn = document.getElementById('toggleBBoxHelper');
      const toggleAxesBtn = document.getElementById('toggleAxes');
      const toggleMarkersBtn = document.getElementById('toggleMarkers');
      const toggleLocalAxesBtn = document.getElementById('toggleLocalAxes');
      const autoCenterBtn = document.getElementById('autoCenter');
      const nodeList = document.getElementById('nodeList');
      const findFirstMeshBtn = document.getElementById('findFirstMesh');
      const resetTransformsBtn = document.getElementById('resetTransforms');

      fileInput.addEventListener('change', async (ev) => {
        const f = ev.target.files[0];
        if (f) {
          const url = URL.createObjectURL(f);
          await loadGLB(url, f.name);
          URL.revokeObjectURL(url);
        }
      });

      loadUrlBtn.addEventListener('click', async () => {
        const url = urlInput.value.trim();
        if (!url) { alert('è¯·è¾“å…¥ glb/gltf URL'); return; }
        await loadGLB(url, url);
      });

      toggleBBoxBtn.addEventListener('click', () => {
        bboxHelperVisible = !bboxHelperVisible;
        if (boxHelper) boxHelper.visible = bboxHelperVisible;
      });

      toggleAxesBtn.addEventListener('click', () => {
        axesHelper.visible = !axesHelper.visible;
      });

      toggleMarkersBtn.addEventListener('click', () => {
        markersVisible = !markersVisible;
        updateMarkersVisibility();
      });

      toggleLocalAxesBtn.addEventListener('click', () => {
        localAxesVisible = !localAxesVisible;
        if (localAxesHelper) localAxesHelper.visible = localAxesVisible;
      });

      autoCenterBtn.addEventListener('click', () => {
        if (!loadedRoot) return alert('è¯·å…ˆåŠ è½½æ¨¡å‹');
        centerModelToBBox(loadedRoot);
      });

      findFirstMeshBtn.addEventListener('click', () => {
        if (!loadedRoot) return alert('è¯·å…ˆåŠ è½½æ¨¡å‹');
        const mesh = findFirstMesh(loadedRoot);
        if (mesh) selectNode(mesh);
        else alert('æœªæ‰¾åˆ° mesh èŠ‚ç‚¹');
      });

      resetTransformsBtn.addEventListener('click', () => {
        if (!loadedRoot) return alert('è¯·å…ˆåŠ è½½æ¨¡å‹');
        loadedRoot.position.set(0, 0, 0);
        loadedRoot.rotation.set(0, 0, 0);
        loadedRoot.scale.set(1, 1, 1);
        updateAllHelpers();
      });

      // ç‚¹å‡»èŠ‚ç‚¹åˆ—è¡¨é€‰æ‹©
      nodeList.addEventListener('click', (ev) => {
        const el = ev.target.closest('.node-item');
        if (!el) return;
        const uuid = el.dataset.uuid;
        const obj = scene.getObjectByProperty('uuid', uuid);
        if (obj) selectNode(obj);
      });

      // æ”¯æŒæ‹–æ‹½åˆ°è§†å›¾
      container.addEventListener('dragover', (e) => { e.preventDefault(); });
      container.addEventListener('drop', async (e) => {
        e.preventDefault();
        const f = e.dataTransfer.files?.[0];
        if (f) {
          const url = URL.createObjectURL(f);
          await loadGLB(url, f.name);
          URL.revokeObjectURL(url);
        }
      });
    }

    // åŠ è½½ glb/gltf
    async function loadGLB(url, name = 'model') {
      // æ¸…ç†æ—§æ¨¡å‹
      if (loadedRoot) {
        scene.remove(loadedRoot);
        disposeObject(loadedRoot);
        loadedRoot = null;
      }
      if (boxHelper) { scene.remove(boxHelper); boxHelper = null; }
      if (pivotSphere) { scene.remove(pivotSphere); pivotSphere = null; }
      if (bboxCenterSphere) { scene.remove(bboxCenterSphere); bboxCenterSphere = null; }
      if (localAxesHelper) { scene.remove(localAxesHelper); localAxesHelper = null; }

      const loader = new GLTFLoader();
      try {
        const gltf = await new Promise((resolve, reject) => loader.load(url, resolve, undefined, reject));
        loadedRoot = gltf.scene || gltf.scenes?.[0] || null;
        if (!loadedRoot) return alert('æ¨¡å‹åŠ è½½åæœªæ‰¾åˆ° scene');

        // ä¸ºäº†è°ƒè¯•æ–¹ä¾¿ï¼ŒæŠŠæ¨¡å‹ä»¥ä¸€ä¸ªå®¹å™¨ Group åŒ…èµ·æ¥ï¼ˆå¦‚æœå®ƒå·²ç»æ˜¯ Group ä¹Ÿæ²¡äº‹ï¼‰
        const containerGroup = new THREE.Group();
        containerGroup.name = `ROOT_${name}`;
        containerGroup.add(loadedRoot);
        scene.add(containerGroup);
        loadedRoot = containerGroup; // ä½¿ç”¨ containerGroup ä½œä¸ºæ“ä½œ root

        // è‡ªåŠ¨ç¼©æ”¾/å±…ä¸­è§†è§’ï¼šè®¡ç®— bbox å¹¶ç¼©æ”¾æ‘„åƒæœºè·ç¦»
        fitCameraToObject(camera, controls, loadedRoot, 1.2);

        // æ·»åŠ  box helperï¼ˆå¯è§åŒ…å›´ç›’ï¼‰
        const box = new THREE.Box3().setFromObject(loadedRoot);
        boxHelper = new THREE.Box3Helper(box, 0xffffff);
        scene.add(boxHelper);

        // å»ºç«‹å¯è§† markerï¼ˆpivot / bbox centerï¼‰
        pivotSphere = createMarkerSphere(0.04, 0xef4444); // çº¢è‰² pivot
        bboxCenterSphere = createMarkerSphere(0.05, 0x3b82f6); // è“è‰² bbox center
        scene.add(pivotSphere);
        scene.add(bboxCenterSphere);

        // æ›´æ–°èŠ‚ç‚¹æ ‘UI
        buildNodeList(loadedRoot);

        // é€‰æ‹©é»˜è®¤èŠ‚ç‚¹ï¼ˆroot.children[0] if existsï¼‰
        if (loadedRoot.children.length > 0) selectNode(loadedRoot.children[0]);
        else selectNode(loadedRoot);

        updateAllHelpers();
      } catch (err) {
        console.error(err);
        alert('åŠ è½½æ¨¡å‹å¤±è´¥ï¼Œè§æ§åˆ¶å°');
      }
    }

    function disposeObject(obj) {
      obj.traverse((c) => {
        if (c.geometry) c.geometry.dispose();
        if (c.material) {
          if (Array.isArray(c.material)) c.material.forEach(m => m.dispose());
          else c.material.dispose();
        }
      });
    }

    // åˆ›å»ºå¯è§†çƒä½“ marker
    function createMarkerSphere(radius = 0.05, color = 0xff0000) {
      const geo = new THREE.SphereGeometry(radius, 16, 12);
      const mat = new THREE.MeshBasicMaterial({ color: color });
      const m = new THREE.Mesh(geo, mat);
      m.renderOrder = 999;
      m.frustumCulled = false;
      return m;
    }

    // æ›´æ–°æ˜¾ç¤ºæ‰€æœ‰ helperï¼šbbox helperã€è½´ã€marker
    function updateAllHelpers() {
      if (!loadedRoot) return;
      // æ›´æ–° boxHelper
      const box = new THREE.Box3().setFromObject(loadedRoot);
      if (boxHelper) {
        scene.remove(boxHelper);
        boxHelper = new THREE.Box3Helper(box, 0xffffff);
        boxHelper.visible = bboxHelperVisible;
        scene.add(boxHelper);
      } else {
        boxHelper = new THREE.Box3Helper(box, 0xffffff);
        boxHelper.visible = bboxHelperVisible;
        scene.add(boxHelper);
      }
      updateMarkersVisibility();
      updateMarkerPositionsForSelected();
    }

    // æ˜¾ç¤ºæˆ–éšè— marker
    function updateMarkersVisibility() {
      if (pivotSphere) pivotSphere.visible = markersVisible;
      if (bboxCenterSphere) bboxCenterSphere.visible = markersVisible;
      if (labelPivot) labelPivot.style.display = markersVisible ? 'block' : 'none';
      if (labelBBox) labelBBox.style.display = markersVisible ? 'block' : 'none';
      if (labelScene) labelScene.style.display = markersVisible ? 'block' : 'none';
    }

    // é€‰æ‹©èŠ‚ç‚¹
    function selectNode(obj) {
      currentSelected = obj;
      highlightNodeInList(obj);
      updateMarkerPositionsForSelected();
      updateLocalAxesHelper();
      showSelectedInfo();
    }

    // åœ¨å·¦ä¾§èŠ‚ç‚¹æ ‘ä¸­é«˜äº®
    function highlightNodeInList(obj) {
      const items = document.querySelectorAll('.node-item');
      items.forEach(it => it.classList.toggle('selected', it.dataset.uuid === obj.uuid));
    }

    // æ›´æ–°å±€éƒ¨åæ ‡ç³»è¾…åŠ©çº¿
    function updateLocalAxesHelper() {
      if (localAxesHelper) {
        scene.remove(localAxesHelper);
        localAxesHelper = null;
      }

      if (!currentSelected) return;

      // åˆ›å»ºå±€éƒ¨åæ ‡ç³»ï¼ˆæ˜¾ç¤ºåœ¨èŠ‚ç‚¹çš„ local origin ä½ç½®ï¼‰
      localAxesHelper = new THREE.AxesHelper(0.5);

      // è·å–èŠ‚ç‚¹çš„ä¸–ç•Œå˜æ¢
      currentSelected.updateWorldMatrix(true, false);
      const worldPos = new THREE.Vector3();
      currentSelected.localToWorld(worldPos.set(0, 0, 0));

      // è®¾ç½®ä½ç½®å’Œæ—‹è½¬
      localAxesHelper.position.copy(worldPos);
      localAxesHelper.quaternion.copy(currentSelected.getWorldQuaternion(new THREE.Quaternion()));

      // æ ¹æ®åŒ…å›´ç›’å¤§å°è°ƒæ•´åæ ‡è½´é•¿åº¦
      const box = new THREE.Box3().setFromObject(currentSelected);
      const size = box.getSize(new THREE.Vector3());
      const maxSize = Math.max(size.x, size.y, size.z);
      localAxesHelper.scale.setScalar(Math.max(0.3, maxSize * 0.3));

      localAxesHelper.visible = localAxesVisible;
      scene.add(localAxesHelper);
    }

    // æ„å»ºèŠ‚ç‚¹æ ‘ï¼ˆå¹³çº§åˆ—è¡¨ï¼ŒåŒ…å« indentï¼‰
    function buildNodeList(root) {
      const nodeList = document.getElementById('nodeList');
      nodeList.innerHTML = '';
      const rows = [];
      function walk(node, depth = 0) {
        const name = node.name || node.type;
        const el = document.createElement('div');
        el.className = 'node-item';
        el.style.paddingLeft = (8 + depth * 10) + 'px';
        el.dataset.uuid = node.uuid;
        el.textContent = `${name} (${node.type})`;
        nodeList.appendChild(el);
        for (const ch of node.children) walk(ch, depth + 1);
      }
      walk(root, 0);
    }

    // æ˜¾ç¤ºé€‰æ‹©èŠ‚ç‚¹çš„ä¿¡æ¯ï¼ˆpivot å’Œ bboxï¼‰- è¯¦ç»†æ•™å­¦ç‰ˆ
    function showSelectedInfo() {
      const info = document.getElementById('selectedInfo');
      if (!currentSelected) {
        info.innerHTML = '<div class="small" style="color: #64748b;">è¯·åœ¨èŠ‚ç‚¹æ ‘ä¸­é€‰æ‹©ä¸€ä¸ªèŠ‚ç‚¹</div>';
        return;
      }

      // 1. è·å–èŠ‚ç‚¹çš„å±€éƒ¨åæ ‡
      const localPos = currentSelected.position.clone();
      const localRot = currentSelected.rotation.clone();
      const localScale = currentSelected.scale.clone();

      // 2. pivot world pos (å±€éƒ¨åŸç‚¹çš„ä¸–ç•Œåæ ‡)
      const pivotWorld = new THREE.Vector3();
      currentSelected.updateWorldMatrix(true, false);
      currentSelected.localToWorld(pivotWorld.set(0, 0, 0));

      // 3. bbox (åŸºäºæ•´ä¸ª selected å­æ ‘)
      const box = new THREE.Box3().setFromObject(currentSelected);
      const bboxCenter = box.getCenter(new THREE.Vector3());
      const bboxSize = box.getSize(new THREE.Vector3());
      const bboxMin = box.min;
      const bboxMax = box.max;

      // 4. è®¡ç®—åç§»é‡ï¼ˆLocal Origin å’Œ BBox Center çš„å·®å€¼ï¼‰
      const offset = new THREE.Vector3().subVectors(bboxCenter, pivotWorld);

      // 5. è·å–çˆ¶èŠ‚ç‚¹ä¿¡æ¯
      const parentInfo = currentSelected.parent
        ? `${currentSelected.parent.name || currentSelected.parent.type}`
        : 'æ—  (æ ¹èŠ‚ç‚¹)';

      // 6. ä¸–ç•Œå˜æ¢çŸ©é˜µ
      const worldMatrix = currentSelected.matrixWorld.clone();

      info.innerHTML = `
    <div style="background: #1a2332; padding: 8px; border-radius: 6px; margin-bottom: 8px;">
      <div style="font-weight: bold; color: #0ea5a5; margin-bottom: 6px;">
        å½“å‰èŠ‚ç‚¹: <span style="color: #fbbf24;">${currentSelected.name || '(unnamed)'}</span>
      </div>
      <div class="small">ç±»å‹: ${currentSelected.type} | çˆ¶èŠ‚ç‚¹: ${parentInfo}</div>
    </div>

    <!-- è®¡ç®—æ­¥éª¤ 1: Local Origin -->
    <div class="step-box">
      <div class="step-title">ğŸ”´ æ­¥éª¤1: è®¡ç®— Local Origin (å±€éƒ¨åŸç‚¹)</div>
      <div class="small">å±€éƒ¨åæ ‡ç³»çš„åŸç‚¹ï¼Œæ‰€æœ‰å˜æ¢çš„"é”šç‚¹"</div>
      <div class="formula">localOrigin = Vector3(0, 0, 0)</div>
      <div class="small" style="margin-top: 4px;">è½¬æ¢åˆ°ä¸–ç•Œåæ ‡:</div>
      <div class="formula">worldOrigin = node.localToWorld(localOrigin)</div>
      <div class="calc-result">
        <strong>ç»“æœ:</strong> (${vToStr(pivotWorld)})
      </div>
    </div>

    <!-- èŠ‚ç‚¹çš„å±€éƒ¨å˜æ¢ -->
    <div class="step-box">
      <div class="step-title">ğŸ“ èŠ‚ç‚¹çš„å±€éƒ¨å˜æ¢</div>
      <div class="small">ç›¸å¯¹äºçˆ¶èŠ‚ç‚¹çš„å˜æ¢</div>
      <div class="calc-result">
        <strong>ä½ç½® (Position):</strong> (${vToStr(localPos)})<br/>
        <strong>æ—‹è½¬ (Rotation):</strong> (${localRot.x.toFixed(3)}, ${localRot.y.toFixed(3)}, ${localRot.z.toFixed(3)}) rad<br/>
        <strong>ç¼©æ”¾ (Scale):</strong> (${vToStr(localScale)})
      </div>
    </div>

    <!-- è®¡ç®—æ­¥éª¤ 2: BBox -->
    <div class="step-box">
      <div class="step-title">ğŸ”µ æ­¥éª¤2: è®¡ç®— BBox Center (åŒ…å›´ç›’ä¸­å¿ƒ)</div>
      <div class="small">éå†èŠ‚ç‚¹åŠå…¶å­èŠ‚ç‚¹çš„æ‰€æœ‰é¡¶ç‚¹ï¼Œè®¡ç®—AABB</div>
      <div class="formula">
        box = new Box3().setFromObject(node)<br/>
        // éå†æ‰€æœ‰ mesh çš„é¡¶ç‚¹ï¼Œæ‰¾å‡º min/max
      </div>
      <div class="calc-result">
        <strong>åŒ…å›´ç›’èŒƒå›´:</strong><br/>
        Min: (${vToStr(bboxMin)})<br/>
        Max: (${vToStr(bboxMax)})
      </div>
      <div class="small" style="margin-top: 4px;">è®¡ç®—ä¸­å¿ƒç‚¹:</div>
      <div class="formula">center = (min + max) / 2</div>
      <div class="calc-result">
        <strong>ç»“æœ:</strong> (${vToStr(bboxCenter)})
      </div>
      <div class="calc-result" style="margin-top: 4px;">
        <strong>åŒ…å›´ç›’å°ºå¯¸:</strong> (${vToStr(bboxSize)})
      </div>
    </div>

    <!-- è®¡ç®—æ­¥éª¤ 3: å¯¹æ¯” -->
    <div class="step-box" style="background: #1e293b;">
      <div class="step-title">ğŸ“Š æ­¥éª¤3: å¯¹æ¯”ä¸¤ä¸ªä¸­å¿ƒ</div>
      <div class="small">è®¡ç®— BBox Center ç›¸å¯¹äº Local Origin çš„åç§»</div>
      <div class="formula">offset = bboxCenter - localOrigin</div>
      <div class="calc-result">
        <strong>åç§»é‡:</strong> (${vToStr(offset)})<br/>
        <strong>åç§»è·ç¦»:</strong> ${offset.length().toFixed(3)} å•ä½
      </div>
      <div class="small" style="margin-top: 6px; color: #94a3b8;">
        ${offset.length() < 0.001
          ? 'âœ… Local Origin å’Œ BBox Center åŸºæœ¬é‡åˆï¼Œæ¨¡å‹å·²å±…ä¸­ï¼'
          : 'âš ï¸ Local Origin åç¦»å‡ ä½•ä¸­å¿ƒï¼Œè¿™æ˜¯å¸¸è§æƒ…å†µã€‚<br/>å¯ä»¥ä½¿ç”¨"å±…ä¸­åˆ°BBoxä¸­å¿ƒ"æŒ‰é’®è°ƒæ•´ã€‚'
        }
      </div>
    </div>

    <!-- å…³é”®æ¦‚å¿µè¯´æ˜ -->
    <div style="background: #0f1a2a; padding: 8px; border-radius: 6px; margin-top: 8px; font-size: 11px; color: #94a3b8;">
      <div style="font-weight: bold; color: #60a5fa; margin-bottom: 4px;">ğŸ’¡ å…³é”®ç†è§£</div>
      <ul style="margin: 4px 0; padding-left: 20px;">
        <li><strong>Local Origin</strong>: å–å†³äºå»ºæ¨¡æ—¶è®¾ç½®çš„åŸç‚¹ä½ç½®</li>
        <li><strong>BBox Center</strong>: æ€»æ˜¯å‡ ä½•ä½“çš„è§†è§‰ä¸­å¿ƒ</li>
        <li>ä¸¤è€…ä¸åŒæ—¶ï¼Œæ—‹è½¬ä¼šå›´ç»• Local Origin è¿›è¡Œ</li>
        <li>å±…ä¸­æ“ä½œä¼šè°ƒæ•´ positionï¼Œä½¿ Local Origin ç§»åˆ° BBox Center</li>
      </ul>
    </div>
  `;

      // æ›´æ–° label texts
      pivotText.textContent = vToStr(pivotWorld);
      bboxText.textContent = vToStr(bboxCenter);
    }

    // æ›´æ–° marker ä½ç½®ï¼ˆåŸºäº currentSelectedï¼‰
    function updateMarkerPositionsForSelected() {
      if (!currentSelected) return;
      // pivot world pos
      const pivotWorld = new THREE.Vector3();
      currentSelected.updateWorldMatrix(true, false);
      currentSelected.localToWorld(pivotWorld.set(0, 0, 0));
      if (pivotSphere) pivotSphere.position.copy(pivotWorld);

      // bbox center (for selected subtree)
      const box = new THREE.Box3().setFromObject(currentSelected);
      const bboxCenter = box.getCenter(new THREE.Vector3());
      if (bboxCenterSphere) bboxCenterSphere.position.copy(bboxCenter);

      // scene origin is fixed at (0,0,0) already
      if (labelScene) labelScene.style.display = markersVisible ? 'block' : 'none';
    }

    // åœ¨ render loop ä¸­æ›´æ–°å±å¹•ä¸Šçš„æ ‡ç­¾ä½ç½®
    function updateScreenLabels() {
      if (!currentSelected) return;
      const pivotWorld = pivotSphere ? pivotSphere.position : null;
      const bboxWorld = bboxCenterSphere ? bboxCenterSphere.position : null;
      if (pivotWorld) setLabelPosition(labelPivot, pivotWorld);
      if (bboxWorld) setLabelPosition(labelBBox, bboxWorld);
      // scene origin label
      setLabelPosition(labelScene, new THREE.Vector3(0, 0, 0));
    }

    // æŠŠä¸–ç•Œåæ ‡æŠ•å½±åˆ°å±å¹•å¹¶æ”¾ç½® HTML label
    function setLabelPosition(labelEl, worldPos) {
      const vector = worldPos.clone().project(camera);
      const x = (vector.x * 0.5 + 0.5) * renderer.domElement.clientWidth;
      const y = (-vector.y * 0.5 + 0.5) * renderer.domElement.clientHeight;
      labelEl.style.transform = 'translate(-50%,-120%)';
      labelEl.style.left = `${x}px`;
      labelEl.style.top = `${y}px`;
    }

    // è¾…åŠ©ï¼šå‘é‡è½¬å­—ç¬¦ä¸²
    function vToStr(v) {
      return `${v.x.toFixed(3)}, ${v.y.toFixed(3)}, ${v.z.toFixed(3)}`;
    }

    // æŸ¥æ‰¾ç¬¬ä¸€ä¸ª mesh
    function findFirstMesh(root) {
      let found = null;
      root.traverse((c) => {
        if (!found && c.isMesh) found = c;
      });
      return found;
    }

    // æŠŠæ¨¡å‹çš„å‡ ä½•ä¸­å¿ƒç§»åŠ¨åˆ°æ¨¡å‹å±€éƒ¨åŸç‚¹ï¼ˆç­‰æ•ˆ Three.js ä¾§æŠŠ bbox center ç§»åˆ° local originï¼‰
    // æ³¨æ„ï¼šè¿™ä¼šä¿®æ”¹ model çš„ positionï¼ˆå¹³ç§»æ•´ä¸ª rootï¼‰ï¼Œä¸æ˜¯ä¿®æ”¹åŸå§‹ mesh é¡¶ç‚¹
    function centerModelToBBox(root) {
      // 1. è®¡ç®—å½“å‰çš„ bbox centerï¼ˆåŸºäº root å­æ ‘ï¼‰
      const box = new THREE.Box3().setFromObject(root);
      const oldCenter = box.getCenter(new THREE.Vector3());

      // 2. è®¡ç®—å½“å‰çš„ local origin ä¸–ç•Œåæ ‡
      const oldOrigin = new THREE.Vector3();
      root.updateWorldMatrix(true, false);
      root.localToWorld(oldOrigin.set(0, 0, 0));

      // 3. è®¡ç®—åç§»é‡
      const offset = new THREE.Vector3().subVectors(oldCenter, oldOrigin);

      console.log('ğŸ¯ æ‰§è¡Œå±…ä¸­æ“ä½œ:');
      console.log('  - åŸ BBox Center:', oldCenter.toArray());
      console.log('  - åŸ Local Origin:', oldOrigin.toArray());
      console.log('  - åç§»é‡:', offset.toArray());

      // 4. å°† root ç§»åŠ¨ï¼ˆå¹³ç§»æ•´ä¸ªå®¹å™¨ï¼‰â€”â€”æŠŠå‡ ä½•ä¸­å¿ƒç§»åŠ¨åˆ° root çš„ local origin
      // å®é™…ä¸Šæ˜¯è®© local origin ç§»åŠ¨åˆ° bbox center çš„ä½ç½®
      root.position.sub(oldCenter);

      console.log('  - æ–° Position:', root.position.toArray());
      console.log('âœ… å±…ä¸­å®Œæˆï¼ç°åœ¨ Local Origin ä¸ BBox Center é‡åˆ');

      updateAllHelpers();
      if (currentSelected === root || root.children.includes(currentSelected)) {
        selectNode(currentSelected); // åˆ·æ–°æ˜¾ç¤º
      }
    }

    // camera fit
    function fitCameraToObject(camera, controls, object, offset = 1.25) {
      // object: THREE.Object3D
      const box = new THREE.Box3().setFromObject(object);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      // get max size of the object (AABB)
      const maxSize = Math.max(size.x, size.y, size.z);
      const fitHeightDistance = maxSize / (2 * Math.atan(Math.PI * camera.fov / 360));
      const fitWidthDistance = fitHeightDistance / camera.aspect;
      const distance = offset * Math.max(fitHeightDistance, fitWidthDistance);

      // set camera to frame
      camera.position.copy(center);
      camera.position.x += distance;
      camera.position.y += distance * 0.6;
      camera.position.z += distance;
      camera.lookAt(center);

      // update controls
      if (controls) {
        controls.target.copy(center);
        controls.update();
      }
    }

    // æ‰“å°æ•´ä¸ª scene å¯¹è±¡ç»“æ„ï¼ˆconsoleï¼‰
    function logSceneTree(root) {
      root.traverse((n) => {
        console.log(n.type, n.name || '', n.uuid, 'pos', n.position.toArray(), 'rot', n.rotation.toArray(), 'scale', n.scale.toArray());
      });
    }

    // æŸ¥æ‰¾æ‰¿è½½ origin åç§»çš„èŠ‚ç‚¹ï¼ˆç®€å• heuristicï¼šposition != 0 æˆ– rotation != 0 æˆ– scale != 1ï¼‰
    function findNodesWithNonIdentityTransform(root) {
      const res = [];
      root.traverse((n) => {
        if (n === root) return;
        if (!n.isObject3D) return;
        if (n.position.x !== 0 || n.position.y !== 0 || n.position.z !== 0 ||
          n.rotation.x !== 0 || n.rotation.y !== 0 || n.rotation.z !== 0 ||
          n.scale.x !== 1 || n.scale.y !== 1 || n.scale.z !== 1) {
          res.push(n);
        }
      });
      return res;
    }

    // å¸§å¾ªç¯
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      if (loadedRoot && currentSelected) {
        updateMarkerPositionsForSelected();
        updateScreenLabels();
        // æ›´æ–°å±€éƒ¨åæ ‡ç³»ä½ç½®ï¼ˆå¦‚æœèŠ‚ç‚¹æœ‰åŠ¨ç”»æˆ–å˜æ¢ï¼‰
        if (localAxesHelper && localAxesHelper.visible) {
          const worldPos = new THREE.Vector3();
          currentSelected.updateWorldMatrix(true, false);
          currentSelected.localToWorld(worldPos.set(0, 0, 0));
          localAxesHelper.position.copy(worldPos);
          localAxesHelper.quaternion.copy(currentSelected.getWorldQuaternion(new THREE.Quaternion()));
        }
      }
      renderer.render(scene, camera);
    }

    // çª—å£å¤§å°æ”¹å˜
    function onWindowResize() {
      camera.aspect = container.clientWidth / container.clientHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(container.clientWidth, container.clientHeight);
    }

    // è¾…åŠ©ï¼šæŠŠ world pos è¾“å‡ºåˆ°æ§åˆ¶å°ï¼ˆè¯¦ç»†ç‰ˆ - ç”¨äºå­¦ä¹ ï¼‰
    function debugPrintCurrent() {
      if (!currentSelected) return console.warn('âŒ æœªé€‰æ‹©èŠ‚ç‚¹');

      console.log('='.repeat(60));
      console.log('ğŸ“Š å½“å‰èŠ‚ç‚¹è¯¦ç»†ä¿¡æ¯');
      console.log('='.repeat(60));

      // åŸºæœ¬ä¿¡æ¯
      console.log('\nğŸ“Œ åŸºæœ¬ä¿¡æ¯:');
      console.log('  åç§°:', currentSelected.name || '(unnamed)');
      console.log('  ç±»å‹:', currentSelected.type);
      console.log('  UUID:', currentSelected.uuid);

      // å±€éƒ¨å˜æ¢
      console.log('\nğŸ“ å±€éƒ¨å˜æ¢ (ç›¸å¯¹çˆ¶èŠ‚ç‚¹):');
      console.log('  Position:', currentSelected.position.toArray());
      console.log('  Rotation:', currentSelected.rotation.toArray(), '(å¼§åº¦)');
      console.log('  Scale:', currentSelected.scale.toArray());

      // Local Origin ä¸–ç•Œåæ ‡
      currentSelected.updateWorldMatrix(true, false);
      const pivotWorld = new THREE.Vector3().set(0, 0, 0);
      currentSelected.localToWorld(pivotWorld);
      console.log('\nğŸ”´ Local Origin (å±€éƒ¨åŸç‚¹):');
      console.log('  å±€éƒ¨åæ ‡:', [0, 0, 0]);
      console.log('  ä¸–ç•Œåæ ‡:', pivotWorld.toArray());

      // BBox ä¿¡æ¯
      const box = new THREE.Box3().setFromObject(currentSelected);
      const bboxCenter = box.getCenter(new THREE.Vector3());
      const bboxSize = box.getSize(new THREE.Vector3());
      console.log('\nğŸ”µ BBox (åŒ…å›´ç›’):');
      console.log('  Min:', box.min.toArray());
      console.log('  Max:', box.max.toArray());
      console.log('  Center:', bboxCenter.toArray());
      console.log('  Size:', bboxSize.toArray());

      // åç§»é‡
      const offset = new THREE.Vector3().subVectors(bboxCenter, pivotWorld);
      console.log('\nğŸ“Š åç§»åˆ†æ:');
      console.log('  BBox Center - Local Origin:', offset.toArray());
      console.log('  åç§»è·ç¦»:', offset.length().toFixed(4));

      if (offset.length() < 0.001) {
        console.log('  âœ… Local Origin å’Œ BBox Center åŸºæœ¬é‡åˆï¼');
      } else {
        console.log('  âš ï¸ Local Origin åç¦»å‡ ä½•ä¸­å¿ƒ');
      }

      // ä¸–ç•ŒçŸ©é˜µ
      console.log('\nğŸŒ ä¸–ç•Œå˜æ¢çŸ©é˜µ:');
      const m = currentSelected.matrixWorld.elements;
      console.log('  [', m[0].toFixed(3), m[4].toFixed(3), m[8].toFixed(3), m[12].toFixed(3), ']');
      console.log('  [', m[1].toFixed(3), m[5].toFixed(3), m[9].toFixed(3), m[13].toFixed(3), ']');
      console.log('  [', m[2].toFixed(3), m[6].toFixed(3), m[10].toFixed(3), m[14].toFixed(3), ']');
      console.log('  [', m[3].toFixed(3), m[7].toFixed(3), m[11].toFixed(3), m[15].toFixed(3), ']');

      console.log('='.repeat(60));
    }

    // å°†å¯¹è±¡ world åæ ‡è½¬æ¢æˆè¯¥å¯¹è±¡å±€éƒ¨åæ ‡ï¼ˆç¤ºä¾‹ç”¨ï¼‰
    function worldToLocalExample(worldVec, obj) {
      // worldVec: THREE.Vector3
      // obj: target object
      const clone = worldVec.clone();
      obj.worldToLocal(clone);
      return clone;
    }

    // expose some helpers to window for convenience
    window._debug = {
      findFirstMesh, findNodesWithNonIdentityTransform, logSceneTree, debugPrintCurrent, centerModelToBBox
    };

  </script>
</body>

</html>