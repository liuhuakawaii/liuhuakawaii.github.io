<!doctype html>
<html lang="zh-CN">

<head>
  <meta charset="utf-8" />
  <title>GLB 爆炸 / 聚拢 Demo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    html,
    body {
      height: 100%;
      margin: 0;
      background: #0f1115;
      color: #e5e7eb;
      font-family: ui-sans-serif, system-ui;
    }

    #app {
      height: 100%;
      display: grid;
      grid-template-rows: auto 1fr;
    }

    header {
      display: flex;
      gap: 12px;
      align-items: center;
      padding: 10px 14px;
      border-bottom: 1px solid #1f2937;
      background: #111827;
      position: sticky;
      top: 0;
      z-index: 10;
    }

    header h1 {
      font-size: 14px;
      font-weight: 600;
      margin: 0 8px 0 0;
      color: #9ca3af;
    }

    input[type=file] {
      color-scheme: dark;
    }

    button {
      background: #2563eb;
      border: none;
      color: white;
      padding: 8px 14px;
      border-radius: 10px;
      cursor: pointer;
      font-weight: 600;
      box-shadow: 0 6px 20px rgba(37, 99, 235, 0.25);
    }

    button.secondary {
      background: #374151;
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .row {
      display: flex;
      gap: 10px;
      align-items: center;
      flex-wrap: wrap;
    }

    .hint {
      color: #9ca3af;
      font-size: 12px;
    }

    #canvas-wrap {
      position: relative;
      height: 100%;
    }

    #info {
      position: absolute;
      left: 10px;
      bottom: 10px;
      background: rgba(17, 24, 39, 0.7);
      backdrop-filter: blur(4px);
      border: 1px solid #1f2937;
      padding: 8px 10px;
      border-radius: 10px;
      font-size: 12px;
      color: #cbd5e1;
    }

    /* 四个折角 */
    .corner {
      position: absolute;
      width: 12px;
      height: 12px;
    }

    .corner::before,
    .corner::after {
      content: '';
      position: absolute;
      background: #fff;
    }

    .corner.tl::before {
      top: 0;
      left: 0;
      width: 2px;
      height: 100%;
    }

    /* 左竖 */
    .corner.tl::after {
      top: 0;
      left: 0;
      width: 100%;
      height: 2px;
    }

    /* 上横 */
    .corner.tr::before {
      top: 0;
      right: 0;
      width: 2px;
      height: 100%;
    }

    /* 右竖 */
    .corner.tr::after {
      top: 0;
      right: 0;
      width: 100%;
      height: 2px;
    }

    /* 上横 */
    .corner.bl::before {
      bottom: 0;
      left: 0;
      width: 2px;
      height: 100%;
    }

    /* 左竖 */
    .corner.bl::after {
      bottom: 0;
      left: 0;
      width: 100%;
      height: 2px;
    }

    /* 下横 */
    .corner.br::before {
      bottom: 0;
      right: 0;
      width: 2px;
      height: 100%;
    }

    /* 右竖 */
    .corner.br::after {
      bottom: 0;
      right: 0;
      width: 100%;
      height: 2px;
    }

    /* 下横 */
  </style>
</head>

<body>
  <div id="app">
    <header>
      <h1>GLB 爆炸 / 聚拢</h1>
      <div class="row">
        <input id="glbInput" type="file" accept=".glb" />
        <button id="toggleBtn" disabled>切换到：爆炸</button>
        <button id="resetCamBtn" class="secondary" disabled>重置相机</button>
      </div>
      <div class="row" style="margin-left:auto;">
        <span class="hint">加载本地 .glb → 点击切换按钮体验爆炸 / 聚拢(需要glb中含有多个mesh)</span>
      </div>
    </header>
    <div id="canvas-wrap">
      <div id="info">状态：<span id="stateLabel">待加载</span></div>
      <div id="selectionCorners">
        <div class="corner tl"></div>
        <div class="corner tr"></div>
        <div class="corner bl"></div>
        <div class="corner br"></div>
      </div>
    </div>
  </div>

  <script src="https://unpkg.com/@tweenjs/tween.js@18.6.4/dist/tween.umd.js"></script>
  <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.179.1/build/three.module.js",
    "three/examples/jsm/controls/OrbitControls.js": "https://unpkg.com/three@0.179.1/examples/jsm/controls/OrbitControls.js",
    "three/examples/jsm/loaders/GLTFLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/GLTFLoader.js",
    "three/examples/jsm/loaders/DRACOLoader.js": "https://unpkg.com/three@0.179.1/examples/jsm/loaders/DRACOLoader.js"
  }
}
</script>

  <script type="module">
    import * as THREE from "three";
    import { OrbitControls } from "three/examples/jsm/controls/OrbitControls.js";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";
    import { DRACOLoader } from "three/examples/jsm/loaders/DRACOLoader.js";

    const TWEENNS = TWEEN;

    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0b0f17);

    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / (window.innerHeight - 52), 0.01, 2000);
    camera.position.set(2.5, 1.8, 3.5);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false, powerPreference: 'high-performance' });
    renderer.setSize(window.innerWidth, window.innerHeight - 52);
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.outputEncoding = THREE.sRGBEncoding;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    document.getElementById('canvas-wrap').appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    scene.add(new THREE.HemisphereLight(0xffffff, 0x222233, 1.0));
    const dir = new THREE.DirectionalLight(0xffffff, 1.0);
    dir.position.set(5, 6, 8);
    scene.add(dir);

    const grid = new THREE.GridHelper(50, 50, 0x233244, 0x1b2433);
    grid.material.opacity = 0.15;
    grid.material.transparent = true;
    grid.position.y = -0.001;
    scene.add(grid);

    const $input = document.getElementById('glbInput');
    const $toggle = document.getElementById('toggleBtn');
    const $resetCam = document.getElementById('resetCamBtn');
    const $stateLabel = document.getElementById('stateLabel');
    const $selectionCorners = document.getElementById('selectionCorners');

    const STATE = { Assembled: '聚拢', Exploded: '爆炸' };
    let mode = STATE.Assembled;

    const modelRoot = new THREE.Object3D();
    scene.add(modelRoot);

    let glbScene = null;
    const meshData = new Map();
    let modelCenter = new THREE.Vector3();
    let modelSize = new THREE.Vector3();
    let modelRadius = 1;

    let floatingEnabled = false;
    const clock = new THREE.Clock();

    function setStateLabel() {
      $stateLabel.textContent = glbScene ? (mode === STATE.Assembled ? '已聚拢' : '已爆炸(悬浮)') : '待加载';
      $toggle.textContent = '切换到：' + (mode === STATE.Assembled ? '爆炸' : '聚拢');
    }

    function clearCurrent() {
      TWEENNS.removeAll();
      if (glbScene) {
        modelRoot.remove(glbScene);
        glbScene.traverse(o => {
          if (o.geometry) o.geometry.dispose?.();
          if (o.material) { const mats = Array.isArray(o.material) ? o.material : [o.material]; mats.forEach(m => m.dispose?.()); }
        });
        glbScene = null;
      }
      meshData.clear();
      floatingEnabled = false;
      modelCenter.set(0, 0, 0); modelSize.set(0, 0, 0); modelRadius = 1;
      modelRoot.position.set(0, 0, 0);
      modelRoot.rotation.set(0, 0, 0);
      modelRoot.scale.set(1, 1, 1);
      mode = STATE.Assembled;
      setStateLabel();
      selectionManager.clear();
    }

    function computeModelBounds(root) {
      const box = new THREE.Box3().setFromObject(root);
      box.getCenter(modelCenter);
      box.getSize(modelSize);
      modelRadius = modelSize.length() / 2;
    }

    function collectMeshes(root) {
      meshData.clear();
      let idx = 0;
      root.traverse(obj => {
        if (obj.isMesh) {
          obj.updateMatrixWorld(true);
          const startWorldPos = new THREE.Vector3().setFromMatrixPosition(obj.matrixWorld);
          const startQuat = new THREE.Quaternion().setFromRotationMatrix(obj.matrixWorld);
          const startLocalPos = obj.position.clone();
          meshData.set(obj, {
            startLocalPos,
            startQuat,
            startWorldPos,
            floatPhase: Math.random() * Math.PI * 2 + idx * 0.3,
            baseExplodedLocalPos: null,
            baseExplodedQuat: null,
          });
          idx++;
        }
      });
    }

    function worldToLocalFor(mesh, worldPos) {
      const invParent = new THREE.Matrix4().copy(mesh.parent.matrixWorld).invert();
      return worldPos.clone().applyMatrix4(invParent);
    }

    function slerpTo(mesh, fromQ, toQ, t) {
      mesh.quaternion.slerp(toQ, t);
    }

    // ---------------------- Explode/Assemble ----------------------
    async function shakeRoot(duration = 500, amplitude = 0.03, rotAmp = 0.03) {
      return new Promise(resolve => {
        const start = { t: 0 };
        new TWEENNS.Tween(start)
          .to({ t: 1 }, duration)
          .easing(TWEENNS.Easing.Quadratic.InOut)
          .onUpdate(() => {
            const s = (1 - Math.abs(0.5 - start.t) * 2);
            modelRoot.position.set((Math.random() - 0.5) * amplitude * s, (Math.random() - 0.5) * amplitude * s, (Math.random() - 0.5) * amplitude * s);
            modelRoot.rotation.set((Math.random() - 0.5) * rotAmp * s, (Math.random() - 0.5) * rotAmp * s, (Math.random() - 0.5) * rotAmp * s);
          })
          .onComplete(() => { modelRoot.position.set(0, 0, 0); modelRoot.rotation.set(0, 0, 0); resolve(); }).start();
      });
    }

    async function explode({ distanceFactor = 0.8, duration = 1000, easing = TWEENNS.Easing.Back.Out } = {}) {
      if (!glbScene) return;
      await shakeRoot();
      glbScene.updateMatrixWorld(true);
      computeModelBounds(glbScene);
      const tweens = [];
      console.log('explode', meshData);
      meshData.forEach((data, mesh) => {
        if (!mesh.parent) return;
        mesh.parent.updateMatrixWorld(true);
        mesh.updateMatrixWorld(true);
        const worldPos = new THREE.Vector3().setFromMatrixPosition(mesh.matrixWorld);
        const dir = worldPos.clone().sub(modelCenter).normalize();
        const d = modelRadius * distanceFactor * (0.6 + 0.4 * (worldPos.distanceTo(modelCenter) / modelRadius));
        const targetWorldPos = worldPos.clone().addScaledVector(dir, d);
        const targetLocalPos = worldToLocalFor(mesh, targetWorldPos);
        const axis = dir.clone().cross(new THREE.Vector3(0, 1, 0));
        if (axis.lengthSq() < 1e-6) axis.set(1, 0, 0);
        axis.normalize();
        const angle = 0.35;
        const qOffset = new THREE.Quaternion().setFromAxisAngle(axis, angle);
        const fromQ = mesh.quaternion.clone();
        const toQ = fromQ.clone().multiply(qOffset);
        data.baseExplodedLocalPos = targetLocalPos.clone();
        data.baseExplodedQuat = toQ.clone();
        tweens.push(new TWEENNS.Tween(mesh.position).to({ x: targetLocalPos.x, y: targetLocalPos.y, z: targetLocalPos.z }, duration).easing(easing).start());
        const qParam = { t: 0 };
        tweens.push(new TWEENNS.Tween(qParam).to({ t: 1 }, duration).easing(easing).onUpdate(() => slerpTo(mesh, fromQ, toQ, qParam.t)).start());
      });
      await waitTweens(tweens);
      floatingEnabled = true;
      mode = STATE.Exploded;
      setStateLabel();
    }

    async function assemble({ duration = 900, easing = TWEENNS.Easing.Cubic.InOut } = {}) {
      if (!glbScene) return;
      floatingEnabled = false;
      const tweens = [];
      meshData.forEach((data, mesh) => {
        const targetLocalPos = data.startLocalPos.clone();
        const targetQuat = data.startQuat.clone();
        tweens.push(new TWEENNS.Tween(mesh.position).to({ x: targetLocalPos.x, y: targetLocalPos.y, z: targetLocalPos.z }, duration).easing(easing).start());
        const qParam = { t: 0 };
        tweens.push(new TWEENNS.Tween(qParam).to({ t: 1 }, duration).easing(easing).onUpdate(() => slerpTo(mesh, mesh.quaternion, targetQuat, qParam.t)).start());
      });
      await waitTweens(tweens);
      mode = STATE.Assembled;
      setStateLabel();
    }

    function waitTweens(tweens) {
      return new Promise(resolve => {
        if (tweens.length === 0) resolve();
        let finished = 0;
        tweens.forEach(t => t.onComplete(() => { finished++; if (finished >= tweens.length) resolve(); }));
      });
    }

    // ---------------------- Floating ----------------------
    function updateFloating(delta) {
      if (!floatingEnabled) return;
      const time = clock.getElapsedTime();
      meshData.forEach((data, mesh) => {
        const phase = data.floatPhase;
        mesh.position.addScaledVector(new THREE.Vector3(Math.sin(time + phase), Math.cos(time + phase * 1.3), Math.sin(time + phase * 0.7)), 0.0007);
        mesh.rotation.x += 0.0007;
        mesh.rotation.y += 0.0009;
      });
    }

    function getScreenBounds(mesh, camera, renderer) {
      const box = new THREE.Box3().setFromObject(mesh);
      const points = [
        new THREE.Vector3(box.min.x, box.min.y, box.min.z),
        new THREE.Vector3(box.min.x, box.min.y, box.max.z),
        new THREE.Vector3(box.min.x, box.max.y, box.min.z),
        new THREE.Vector3(box.min.x, box.max.y, box.max.z),
        new THREE.Vector3(box.max.x, box.min.y, box.min.z),
        new THREE.Vector3(box.max.x, box.min.y, box.max.z),
        new THREE.Vector3(box.max.x, box.max.y, box.min.z),
        new THREE.Vector3(box.max.x, box.max.y, box.max.z),
      ];

      const screenPoints = points.map(p => worldToScreen(p, camera, renderer));
      const xs = screenPoints.map(p => p.x);
      const ys = screenPoints.map(p => p.y);
      return {
        min: { x: Math.min(...xs), y: Math.min(...ys) },
        max: { x: Math.max(...xs), y: Math.max(...ys) },
      };
    }


    // ---------------------- Selection Manager ----------------------
    class SelectionManager {
      constructor(camera, renderer, cornerEl) {
        this.camera = camera;
        this.renderer = renderer;
        this.selectedMesh = null;
        this.cornerEl = cornerEl;
        this.corners = [cornerEl.querySelector('.tl'), cornerEl.querySelector('.tr'), cornerEl.querySelector('.bl'), cornerEl.querySelector('.br')];
      }
      select(mesh) {
        this.clear(); // 清除之前选中高亮
        this.selectedMesh = mesh;

        // 保存原始颜色/材质
        if (mesh.material) {
          this._originalMaterial = mesh.material;
          mesh.material = mesh.material.clone();
          if (mesh.material.emissive) mesh.material.emissive.set(0x00ffff); // 发光高亮
          else mesh.material.color.set(0x00ffff);
          mesh.material.emissiveIntensity = 0.2;
        }

        focusCameraOn(mesh);
        this.cornerEl.style.display = 'block';
      }


      clear() {
        if (this.selectedMesh && this._originalMaterial) {
          this.selectedMesh.material.dispose();
          this.selectedMesh.material = this._originalMaterial;
          this._originalMaterial = null;
        }
        this.selectedMesh = null;
        this.cornerEl.style.display = 'none';
      }



      update() {
        if (!this.selectedMesh) return;
        const { min, max } = getScreenBounds(this.selectedMesh, this.camera, this.renderer);
        const cx = (min.x + max.x) / 2, cy = (min.y + max.y) / 2;
        const w = max.x - min.x, h = max.y - min.y;
        // 更新四个角位置
        this.corners[0].style.left = min.x + 'px'; this.corners[0].style.top = min.y + 'px'; // TL
        this.corners[1].style.left = max.x - 12 + 'px'; this.corners[1].style.top = min.y + 'px'; // TR
        this.corners[2].style.left = min.x + 'px'; this.corners[2].style.top = max.y - 12 + 'px'; // BL
        this.corners[3].style.left = max.x - 12 + 'px'; this.corners[3].style.top = max.y - 12 + 'px'; // BR
      }
    }

    function worldToScreen(pos, camera, renderer) {
      const vector = pos.clone().project(camera);
      const x = (vector.x + 1) / 2 * renderer.domElement.clientWidth;
      const y = (-vector.y + 1) / 2 * renderer.domElement.clientHeight;
      return { x, y };
    }

    function focusCameraOn(mesh) {
      if (!mesh) return;

      const box = new THREE.Box3().setFromObject(mesh);
      const size = box.getSize(new THREE.Vector3());
      const center = box.getCenter(new THREE.Vector3());

      // 计算相机方向：从相机当前位置指向 mesh 中心
      const dir = new THREE.Vector3().subVectors(camera.position, center).normalize();

      // 设置偏移量：沿相机当前方向靠近 mesh，距离大小可调节
      const distance = Math.max(size.length() * 1.5, 3); // 调整倍数和最小距离

      const targetPos = center.clone().add(dir.multiplyScalar(distance));

      const startPos = camera.position.clone();
      const startTarget = controls.target.clone();

      new TWEENNS.Tween({ t: 0 })
        .to({ t: 1 }, 600)
        .easing(TWEENNS.Easing.Cubic.Out)
        .onUpdate(({ t }) => {
          camera.position.lerpVectors(startPos, targetPos, t);
          controls.target.lerpVectors(startTarget, center, t);
          controls.update();
        }).start();
    }

    const selectionManager = new SelectionManager(camera, renderer, $selectionCorners);

    renderer.domElement.addEventListener('pointerdown', event => {
      if (!glbScene) return;
      const mouse = new THREE.Vector2((event.offsetX / renderer.domElement.clientWidth) * 2 - 1, -(event.offsetY / renderer.domElement.clientHeight) * 2 + 1);
      const raycaster = new THREE.Raycaster();
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObjects(Array.from(meshData.keys()), true);
      if (intersects.length > 0) selectionManager.select(intersects[0].object);
    });

    const loader = new GLTFLoader();
    const dracoLoader = new DRACOLoader();
    dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
    loader.setDRACOLoader(dracoLoader);

    $input.addEventListener('change', async e => {
      const file = e.target.files[0];
      if (!file) return;
      clearCurrent();
      const url = URL.createObjectURL(file);
      const gltf = await loader.loadAsync(url);
      glbScene = gltf.scene;
      modelRoot.add(glbScene);
      collectMeshes(glbScene);
      computeModelBounds(glbScene);
      setStateLabel();
      $toggle.disabled = false;
      $resetCam.disabled = false;
      URL.revokeObjectURL(url);
    });

    $toggle.addEventListener('click', async () => { if (mode === STATE.Assembled) await explode(); else await assemble(); });
    $resetCam.addEventListener('click', () => { camera.position.set(2.5, 1.8, 3.5); controls.target.set(0, 0, 0); controls.update(); });

    window.addEventListener('resize', () => { camera.aspect = window.innerWidth / (window.innerHeight - 52); camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight - 52); });

    function animate() {
      requestAnimationFrame(animate);
      TWEENNS.update();
      controls.update();
      updateFloating(clock.getDelta());
      selectionManager.update();
      renderer.render(scene, camera);
    }

    animate();
  </script>
</body>

</html>